

using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Configuration;
using System.Globalization;
using System.Linq;
using System.Linq.Expressions;
using System.Reflection;
using Sgcib.TOne.Configuration;
using Sgcib.TOne.Data.Caching;
using Sgcib.CloudOne.Diagnostics;
using Sgcib.TOne.Diagnostics;
using Sgcib.TOne.Service;
using Sgcib.TOne.StaticData;
using Sgcib.TOne.Util;
using Action = System.Action;

[assembly: TraceSource("Sgcib.TOne.Configuration.DomainSettings", typeof(IDomainSettingsTrace))]

namespace Sgcib.TOne.Configuration
{
    public interface IDomainValidator
    {
        string Name { get; }
        void BeforeSave(Domain domain);
        void BeforeDelete(Domain domain);
    }
    /// <summary>
    /// Represent the use of the Domain
    /// </summary>
    public enum DomainKind
    {
        UndocumentedYetPleaseJustify,
        /// <summary>
        /// Applicatif switch. Used to describe wether or not we need to use the related service
        /// </summary>
        Switch,
        /// <summary>
        /// Domains used for test without any functional or technical meaning behind
        /// </summary>
        ForTestsOnly,
        /// <summary>
        /// Domains used to store a single independant value : Regular Usage of domain
        /// </summary>
        Value,
        /// <summary>
        /// Domains used without value either in TDOMONE or TDOMVALONE.
        /// </summary>
        Empty,
        /// <summary>
        /// Value is a name to an other domain
        /// </summary>
        DomainOfDomain,
        /// <summary>
        /// This kind of domain are lead to be deleted.
        /// </summary>
        SoftTakeOf,
        /// <summary>
        /// This kind of domain are meant to bypass some general purpose behavior in a limited time
        /// </summary>
        BypassSwitch,
        /// <summary>
        /// true if Exists domain, use a DomainSetting bool  to do an applicative switch
        /// </summary>
        TrueIfExists,
    }

    [AttributeUsage(AttributeTargets.Field)]
    public sealed class DomainAttribute : Attribute
    {
        internal readonly string _name;
        internal readonly DomainKind _kind;

        #region .ctor

        public DomainAttribute(string name, DomainKind kind)
        {
            _name = name;
            _kind = kind;
        }


        #endregion

        public bool IsRequired { get; set; }
    }

    public delegate TValue DomainDecoder<TValue>(DomainSetting<TValue> setting, Domain domain);
    public delegate Domain DomainEncoder<TValue>(DomainSetting<TValue> setting, TValue value, Domain domain);

    public sealed class DomainSetting<TValue> : IDomainValidator
    {
        private readonly XOneEnvironment.PropertyLock _syncLock;
        private readonly MemberInfo _member;
        private readonly TValue _defaultValue;
        private readonly string _description;
        private readonly bool _required;
        private readonly DomainDecoder<TValue> _decoder;
        private readonly DomainEncoder<TValue> _encoder;
        private bool _listeningToUpdates;

        #region .ctor

        internal DomainSetting(MemberInfo member
            , DomainDecoder<TValue> decoder
            , DomainEncoder<TValue> encoder = null
            , TValue defaultValue = default(TValue)
            , Action updated = null)
        {
            _member = member;
            _decoder = decoder;
            _encoder = encoder;
            _updated = updated;

            var attr = member.GetCustomAttribute<DomainAttribute>();
            this.Name = attr._name;
            _required = attr.IsRequired;

            _syncLock = new XOneEnvironment.PropertyLock(_member.DeclaringType.GetFriendlyName() + '.' + this.Name);

            DescriptionAttribute desc;
            if (member.TryGetCustomAttribute(out desc))
                _description = desc.Description;

            DefaultValueAttribute def;
            if (member.TryGetCustomAttribute(out def))
            {
                if ((def.Value == null && (typeof(TValue).IsClass || typeof(TValue).IsNullable()))
                    || (def.Value != null && def.Value.GetType() == typeof(TValue)))
                    //check if it's too restricif or not.
                    _defaultValue = (TValue)def.Value;
                else
                {
                    TypeConverter converter = TypeDescriptor.GetConverter(typeof(TValue));
                    _defaultValue = (TValue)converter.ConvertFrom(null, CultureInfo.InvariantCulture, def.Value);

                }
            }
            else
                _defaultValue = defaultValue;

            this.CreateProperty(that => ValueProperty, ResolveValue, sharedLock: _syncLock);

            lock (Domains.Validators)
                Domains.Validators.Add(this.Name, this);

            Warmup.Register(Preload);
        }

        #endregion

        private void Preload()
        {
#pragma warning disable 168
            var value = this.Value;
#pragma warning restore 168
        }

        public static implicit operator TValue(DomainSetting<TValue> setting)
        {
            return setting.Value;
        }

        public string Name { get; private set; }

        #region .Value

#pragma warning disable 649
        private readonly XOneEnvironment.Property<TValue> ValueProperty;
#pragma warning restore 649

        public TValue Value
        {
            get { return ValueProperty.Value; }
            set
            {
                if (_encoder == null)
                    throw DomainSettings.Trace.NoEncoderDefined(this);

                Domain domain;
                lock (_syncLock)
                {

                    domain = CoreServices.Config.Current.GetDomain(this.Name);
                    if (domain == null)
                        domain = new Domain { Name = this.Name };
                    else
                        domain = domain.Clone(); // always edit a copy of the cache object !

                    if (domain.Values.IsReadOnly)
                    {
                        // We need a read/write collection to do our job
                        domain.Values = new DomainValueList(domain.ValuesName.ToList());
                    }

                    domain = WriteValue(domain, value);

                    ListenToCacheUpdates();
                    ValueProperty.Value = value;
                }

                if (domain == null) // means we want to delete the domain
                {
                    domain = new Domain { Name = this.Name };
                    CoreServices.Config.Current.DeleteDomain(domain);
                }
                else
                    CoreServices.Config.Current.SaveDomain(domain);

                ValueProperty.Value = value; // again, because .Value has been invalidated by Save hereabove
            }
        }

        private TValue ResolveValue()
        {
            using (DomainSettings.Trace.ResolveSetting(this))
            {
                ListenToCacheUpdates();
                var domain = CoreServices.Config.Current.GetDomain(this.Name);

                var value = _decoder(this, domain);
                DomainSettings.Trace.SettingResolved(this, value);
                return value;
            }
        }

        internal Domain WriteValue(Domain domain, TValue value)
        {
            if (string.IsNullOrEmpty(domain.Description))
                domain.Description = _description ?? string.Empty;
            return _encoder(this, value, domain);
        }

        public TValue GetDefaultValue()
        {
            if (_required)
                throw DomainSettings.Trace.MissingRequiredSetting(this);
            return _defaultValue;
        }

        #endregion

        private void ListenToCacheUpdates()
        {
            if (_listeningToUpdates)
                return;
            Cache<Domain>.Updated += CacheUpdated;
            _listeningToUpdates = true;
        }

        void IDomainValidator.BeforeSave(Domain domain)
        {
            _decoder(this, domain);
        }

        void IDomainValidator.BeforeDelete(Domain domain)
        {
            if (_required)
                throw DomainSettings.Trace.CantDeleteRequiredSetting(this);
        }

        #region Updated

        private event Action _updated;

        public event Action Updated
        {
            add
            {
                lock (_syncLock)
                    _updated += value;
            }
            remove
            {
                lock (_syncLock)
                    _updated -= value;
            }
        }

        private void CacheUpdated(object sender, CacheEventArgs e)
        {
            if (e.Concerns<Domain>(key => this.Name.Equals(key)))
            {
                lock (_syncLock)
                {
                    ValueProperty.ClearValue();
                    if (_updated != null)
                        _updated();
                }
            }
        }

        #endregion

    }

    public sealed class BooleanString
    {
        public readonly string True;
        public readonly string False;

        public static readonly BooleanString TrueFalse = new BooleanString("true", "false");
        public static readonly BooleanString yn = new BooleanString("y", "n");
        public static readonly BooleanString YesNo = new BooleanString("yes", "no");
        public static readonly BooleanString OuiNon = new BooleanString("o", "n");
        public static readonly BooleanString OneZero = new BooleanString("1", "0");
        public static readonly BooleanString EnableDisable = new BooleanString("enable", "disable");
        public static readonly BooleanString ActiveInactive = new BooleanString("active", "inactive");
        public static readonly BooleanString OnOff = new BooleanString("on", "off");

        #region .ctor

        public BooleanString(string @true, string @false)
        {
            this.True = @true;
            this.False = @false;
        }

        #endregion

        public override string ToString()
        {
            return string.Format("{0} / {1}", True, False);
        }
    }

    #region Codecs

    public abstract class DomainValueConverter<TValue>
        where TValue : struct
    {
        private readonly string _description;
        private readonly Func<string, TValue> _convertFromString;
        private readonly Func<TValue, DomainValue> _convertToString;

        #region .ctor

        internal DomainValueConverter(string description, Func<string, TValue> convertFromString, Func<TValue, DomainValue> convertToString)
        {
            _description = description;
            _convertFromString = convertFromString;
            _convertToString = convertToString;
        }

        #endregion

        public override string ToString()
        {
            return _description;
        }

        internal TValue Decode(DomainSetting<TValue> setting, Domain domain)
        {
            if (domain != null && domain.Values.Any())
                return _convertFromString(domain.ValuesName[0]);
            return setting.GetDefaultValue();
        }

        internal TValue? Decode(DomainSetting<TValue?> setting, Domain domain)
        {
            if (domain != null && domain.Values.Any())
            {
                var asString = domain.ValuesName[0];
                if (string.IsNullOrEmpty(asString))
                    return null;
                return _convertFromString(asString);
            }
            return setting.GetDefaultValue();
        }

        internal Domain Encode(DomainSetting<TValue> setting, TValue value, Domain domain)
        {
            domain.Values = new DomainValueList{ _convertToString(value) };
            return domain;
        }

        internal Domain Encode(DomainSetting<TValue?> setting, TValue? value, Domain domain)
        {
            domain.Values = new DomainValueList{ value.HasValue ? _convertToString(value.Value) : new DomainValue() };
            return domain;
        }
    }

    public sealed class XOneDateFormat : DomainValueConverter<XOneDate>
    {
        #region .ctor

        internal XOneDateFormat(string description, string format)
            : base(description + " (" + format + ')'
                , s => new XOneDate(s, format)
                , dt => new DomainValue(dt.ToString(format)))
        {
        }

        internal XOneDateFormat(string description, Func<string, XOneDate> convertFromString, Func<XOneDate, DomainValue> convertToString)
            : base(description, convertFromString, convertToString)
        {
        }

        #endregion

        public static readonly XOneDateFormat Default = new XOneDateFormat("Date", XOneDate.FORMAT);

        public static readonly XOneDateFormat French = new XOneDateFormat("French (dd/MM/yyyy)", s =>
        {
            XOneDate dt;
            if (!XOneDate.TryParseFromFrenchCulture(s, out dt))
                throw new Exception("Not a French date");
            return dt;
        }, dt => new DomainValue(dt.ToString(XOneDateTime.FrenchCultureInfo)));
    }

    public sealed class XOneDateTimeFormat : DomainValueConverter<XOneDateTime>
    {
        #region .ctor

        internal XOneDateTimeFormat(string description, string format)
            : base(description + " (" + format + ')'
                , s =>
                {
                    XOneDateTime xdt;
                    if (!XOneDateTime.TryParseExact(s, format, out xdt))
                        throw new NotSupportedException(string.Format("Invalid Date/Time {0}. Expects {1}", s, format));
                    return xdt;
                }
                , dt => new DomainValue(dt.ToString(format)))
        {
        }

        internal XOneDateTimeFormat(string description, Func<string, XOneDateTime> convertFromString, Func<XOneDateTime, DomainValue> convertToString)
            : base(description, convertFromString, convertToString)
        {
        }

        #endregion

        public static readonly XOneDateTimeFormat Default = new XOneDateTimeFormat("Date/Time"
            , XOneDateTime.Parse
            , dt => new DomainValue(dt.ToString()));

        public static readonly XOneDateTimeFormat French = new XOneDateTimeFormat("French (dd/MM/yyyy hh:mm:ss) Date/Time"
            , s =>
            {
                XOneDateTime xdt;
                if (!XOneDateTime.TryParseFromFrenchCulture(s, out xdt))
                    throw new NotSupportedException(string.Format("Invalid Date/Time {0}. Expects {1}", s, "dd/MM/yyyy hh:mm:ss"));
                return xdt;
            }
            , dt => new DomainValue(dt.ToString(XOneDateTime.FrenchCultureInfo)));

        public static readonly XOneDateTimeFormat ParisTime = new XOneDateTimeFormat("Paris Date/Time"
            , s => XOneDateTime.FromParisTime(DateTime.Parse(s, CultureInfo.InvariantCulture))
            , dt => new DomainValue(dt.ToParisTime().ToString(CultureInfo.InvariantCulture)));
    }

    public sealed class DateTimeFormat : DomainValueConverter<DateTime>
    {
        #region .ctor

        internal DateTimeFormat(string description, Func<string, DateTime> convertFromString, Func<DateTime, DomainValue> convertToString)
            : base(description, convertFromString, convertToString)
        {
        }

        internal DateTimeFormat(string description, string format)
            : base(description + " (" + format + ')'
                , s => DateTime.ParseExact(s, format, CultureInfo.InvariantCulture)
                , dt => new DomainValue(dt.ToString(format, CultureInfo.InvariantCulture)))
        {
        }

        #endregion

        public static readonly DateTimeFormat French = new DateTimeFormat("French", "dd/MM/yyyy HH:mm:ss");
    }

    public sealed class TimeSpanFormat : DomainValueConverter<TimeSpan>
    {
        #region .ctor

        internal TimeSpanFormat(string description)
            : base(description
                , TimeSpan.Parse
                , ts => new DomainValue(ts.ToString()))
        {
        }

        internal TimeSpanFormat(string description, Func<string, TimeSpan> convertFromString, Func<TimeSpan, DomainValue> convertToString)
            : base(description, convertFromString, convertToString)
        {
        }

        #endregion
    }

    #endregion

    public static class DomainSettings
    {
        #region .ctor

        static DomainSettings()
        {
            TraceUtils.WrapAndInvoke(Boot);
        }

        static void Boot()
        {
            TraceManager.Bind(() => Trace);
        }

        #endregion

        public const string UnknownDomainDescription = "?";

#pragma warning disable 649
        internal static readonly IDomainSettingsTrace Trace;
#pragma warning restore 649

        public static DomainSetting<TValue> Register<TValue>(Expression<Func<DomainSetting<TValue>>> path
            , DomainDecoder<TValue> decoder
            , DomainEncoder<TValue> encoder = null
            , TValue defaultValue = default(TValue)
            , Action updated = null)
        {
            var member = path.GetMember();
            var setting = new DomainSetting<TValue>(member, decoder, encoder, defaultValue, updated);
            member.SetValue(null, setting);
            return setting;
        }

        public static DomainSetting<TValue> Register<TValue>(Expression<Func<DomainSetting<TValue>>> path
            , DomainValueConverter<TValue> converter
            , TValue defaultValue = default(TValue)
            , Action updated = null)
            where TValue : struct
        {
            return Register(path, converter.Decode, converter.Encode, defaultValue, updated);
        }

        public static DomainSetting<TValue?> Register<TValue>(Expression<Func<DomainSetting<TValue?>>> path
            , DomainValueConverter<TValue> converter
            , TValue defaultValue = default(TValue)
            , Action updated = null)
            where TValue : struct
        {
            return Register(path, converter.Decode, converter.Encode, defaultValue, updated);
        }

        #region .String[]

        public static DomainSetting<string[]> Register(Expression<Func<DomainSetting<string[]>>> path
            , DomainDecoder<string[]> decoder = null
            , DomainEncoder<string[]> encoder = null
            , Action updated = null)
        {
            return Register(path, decoder ?? GetStrings, encoder ?? SetStrings, new string[0], updated);
        }

        private static string[] GetStrings(DomainSetting<string[]> setting, Domain domain)
        {
            if (domain == null || domain.Values.Count == 0)
                return setting.GetDefaultValue();
            return domain.ValuesName.ToArray();
        }

        private static Domain SetStrings(DomainSetting<string[]> setting, string[] values, Domain domain)
        {
            Check.ArgumentNotNull(values, "values");
            domain.Values.Clear();
            foreach (var value in values)
                domain.Values.Add(value);
            return domain;
        }

        public static bool ContainsOrANY(this DomainSetting<string[]> setting, object objectToFind)
        {
            return setting.Contains(objectToFind) || setting.Contains(Util.Constants.ANY);
        }

        public static bool Contains(this DomainSetting<string[]> setting, object objectToFind)
        {
            var values = setting.Value;
            var valueToFind = Convert.ToString(objectToFind);
            if (string.IsNullOrEmpty(valueToFind))
                return false;
            return (values != null) && values.Contains(valueToFind, CompareBy.StringIgnoreCaseAndRedundantWhiteSpace);
        }


        public static string GetFirstOrDefaultValue(this DomainSetting<string[]> setting, string defaultValue=null)
        {
            if (setting == null || setting.Value == null)
            {
                return defaultValue;
            }
            var firstValue =  CollectionHelper.FindFirst(setting.Value, item => true);
            return string.IsNullOrEmpty(firstValue) ? defaultValue : firstValue;
        }

        public static void Add(this DomainSetting<string[]> setting, string valueToAdd)
        {
            Check.ArgumentNotNullOrEmptyString(valueToAdd, "valueToAdd");
            if (setting.Contains(valueToAdd))
                return;

            var list = setting.Value.ToList();
            list.Add(valueToAdd);
            setting.Value = list.ToArray();
        }

        public static void Remove(this DomainSetting<string[]> setting, string valueToRemove)
        {
            Check.ArgumentNotNullOrEmptyString(valueToRemove, "valueToRemove");

            var values = setting.Value;
            if (values == null)
                return;

            var list = values.ToList();
            list.Remove(valueToRemove);
            setting.Value = list.ToArray();
        }

        public static void Remove(this DomainSetting<string[]> setting, string valueToRemove, bool ignoreCase = false)
        {
            var valuesList = setting.Value.ToList();
            // handle the case where valueToRemove is null or Empty or if value list is null : dont throw exception
            if (!setting.Contains(valueToRemove) || string.IsNullOrEmpty(valueToRemove) || setting.Value == null)
                return;

            if (ignoreCase)
            {
                int i = valuesList.FindIndex(x => x.Equals(valueToRemove, StringComparison.InvariantCultureIgnoreCase));
                if (i != -1)
                    valuesList.RemoveAt(i);
                else
                    //try remove with regular method
                    valuesList.Remove(valueToRemove);
            }
            else
            {
                valuesList.Remove(valueToRemove);
            }

            setting.Value = valuesList.ToArray();
        }

        #endregion

        #region .string

        public static DomainSetting<string> Register(Expression<Func<DomainSetting<string>>> path
                                                     , DomainDecoder<string> decoder = null
                                                     , DomainEncoder<string> encoder = null
                                                     , string defaultValue = default(string)
                                                     , Action updated = null)
        {
            return Register<string>(path, decoder ?? GetString, encoder ?? SetString, defaultValue, updated: updated);
        }

        private static string GetString(DomainSetting<string> setting, Domain domain)
        {
            if (domain != null && domain.Values.Count > 0)
                return domain.ValuesName[0];
            return setting.GetDefaultValue();
        }

        private static Domain SetString(DomainSetting<string> setting, string value, Domain domain)
        {
            Check.ArgumentNotNull(value, "value");
            domain.Values = new DomainValueList{ value  };
            return domain;
        }

        #endregion

        #region .bool

        private static readonly BooleanString[] BooleanStrings =
        {
            BooleanString.TrueFalse,
            BooleanString.yn,
            BooleanString.YesNo,
            BooleanString.OuiNon,
            BooleanString.OneZero,
            BooleanString.EnableDisable,
            BooleanString.ActiveInactive,
            BooleanString.OnOff,
        };

        public static DomainSetting<bool> Register(Expression<Func<DomainSetting<bool>>> path
            , DomainDecoder<bool> decoder = null
            , DomainEncoder<bool> encoder = null
            , BooleanString booleanString = null
            , bool trueIfExists = false
            , Action updated = null)
        {
            if (trueIfExists)
            {
                if (decoder != null || encoder != null)
                    throw Trace.CantSpecifyBothEncoderDecodeAndTrueIfExists();
                decoder = TrueIfDomainExists;
                encoder = DeleteDomainIfFalse;
            }
            else
            {
                if (decoder == null)
                    decoder = GetBoolean;
                if (encoder == null)
                    encoder = (setting, value, domain) => SetBoolean(setting, value, booleanString, domain);
            }
            return Register<bool>(path, decoder, encoder, updated: updated);
        }

        private static bool TrueIfDomainExists(DomainSetting<bool> setting, Domain domain)
        {
            return (domain != null);
        }

        private static Domain DeleteDomainIfFalse(DomainSetting<bool> setting, bool value, Domain domain)
        {
            if (!value)
                domain = null;
            return domain;
        }

        private static bool GetBoolean(DomainSetting<bool> setting, Domain domain)
        {
            if (domain != null && domain.Values.Count > 0)
            {
                var sValue = domain.ValuesName[0];
                foreach (var pair in BooleanStrings)
                {
                    if (sValue.Equals(pair.True, StringComparison.OrdinalIgnoreCase))
                        return true;
                    if (sValue.Equals(pair.False, StringComparison.OrdinalIgnoreCase))
                        return false;
                }
                throw new NotSupportedException(sValue);
            }
            return setting.GetDefaultValue();
        }

        private static Domain SetBoolean(DomainSetting<bool> setting, bool value, BooleanString booleanString, Domain domain)
        {
            //Check.ArgumentNotNull(booleanString, "booleanString");
            if (domain.Values.Count > 0)
            {
                // try to identify the previous pair, and reuse it
                var sValue = domain.ValuesName[0];
                foreach (var pair in BooleanStrings)
                {
                    if (sValue.Equals(pair.True, StringComparison.OrdinalIgnoreCase) ||
                        sValue.Equals(pair.False, StringComparison.OrdinalIgnoreCase))
                    {
                        booleanString = pair;
                        break;
                    }
                }
            }
            if (booleanString == null)
                booleanString = BooleanString.TrueFalse;

            domain.Values = new DomainValueList { value ? booleanString.True : booleanString.False };
            return domain;
        }

        #endregion

        #region .int

        public static DomainSetting<int> Register(Expression<Func<DomainSetting<int>>> path
                                                  , DomainDecoder<int> decoder = null
                                                  , DomainEncoder<int> encoder = null
                                                  , Action updated = null)
        {
            return Register<int>(path, decoder ?? ReadInteger, encoder ?? UpdateInteger, updated: updated);
        }

        private static int ReadInteger(DomainSetting<int> setting, Domain domain)
        {
            if (domain != null && domain.Values.Count > 0)
                return int.Parse(domain.ValuesName[0]);
            return setting.GetDefaultValue();
        }

        private static Domain UpdateInteger(DomainSetting<int> setting, int value, Domain domain)
        {
            domain.Values.Clear();
            domain.Values.Add(value.ToString());
            return domain;
        }

        #endregion

        #region .int?

        public static DomainSetting<int?> Register(Expression<Func<DomainSetting<int?>>> path
                                                  , DomainDecoder<int?> decoder = null
                                                  , DomainEncoder<int?> encoder = null
                                                  , Action updated = null)
        {
            return Register<int?>(path, decoder ?? ReadInteger, encoder ?? UpdateInteger, updated: updated);
        }

        private static int? ReadInteger(DomainSetting<int?> setting, Domain domain)
        {
            int result;
            if (domain != null && domain.Values.Count > 0)
                if (int.TryParse(domain.ValuesName[0], out result))
                    return result;
                else
                    return null;
            return setting.GetDefaultValue();
        }

        private static Domain UpdateInteger(DomainSetting<int?> setting, int? value, Domain domain)
        {
            domain.Values.Clear();
            if (value == null)
                domain.Values.Add(string.Empty);
            else
            {
                domain.Values.Add(value.ToString());
            }
            return domain;
        }

        #endregion

        #region .double

        public static DomainSetting<double> Register(Expression<Func<DomainSetting<double>>> path
                                                  , DomainDecoder<double> decoder = null
                                                  , DomainEncoder<double> encoder = null
                                                  , Action updated = null)
        {
            return Register<double>(path, decoder ?? ReadDouble, encoder ?? UpdateDouble, updated: updated);
        }

        private static double ReadDouble(DomainSetting<double> setting, Domain domain)
        {
            if (domain != null && domain.Values.Count > 0)
                //only parsing with . is needed as it is a requisitory for Xone
                return double.Parse(domain.ValuesName[0], CultureInfo.InvariantCulture);
            return setting.GetDefaultValue();
        }

        private static Domain UpdateDouble(DomainSetting<double> setting, double value, Domain domain)
        {
            domain.Values.Clear();
            domain.Values.Add(value.ToString(CultureInfo.InvariantCulture));
            return domain;
        }

        #endregion

        #region .double[]

        public static DomainSetting<double[]> Register(Expression<Func<DomainSetting<double[]>>> path
            , DomainDecoder<double[]> decoder = null
            , DomainEncoder<double[]> encoder = null
            , Action updated = null)
        {
            return Register(path, decoder ?? ReadDoubles, encoder ?? UpdateDoubles, new double[0], updated);
        }

        private static double[] ReadDoubles(DomainSetting<double[]> setting, Domain domain)
        {
            if (domain == null || domain.Values.Count == 0)
                return setting.GetDefaultValue();

            return domain.ValuesName.Select(d => double.Parse(d, CultureInfo.InvariantCulture)).ToArray();
        }

        private static Domain UpdateDoubles(DomainSetting<double[]> setting, double[] values, Domain domain)
        {
            domain.Values.Clear();
            foreach (var value in values)
                domain.Values.Add(value.ToString(CultureInfo.InvariantCulture));
            return domain;
        }

        #endregion

        #region .Long

        public static DomainSetting<long> Register(Expression<Func<DomainSetting<long>>> path
                                                  , DomainDecoder<long> decoder = null
                                                  , DomainEncoder<long> encoder = null
                                                  , Action updated = null)
        {
            return Register<long>(path, decoder ?? ReadLong, encoder ?? UpdateLong, updated: updated);
        }

        private static long ReadLong(DomainSetting<long> setting, Domain domain)
        {
            if (domain != null && domain.Values.Count > 0)
                return long.Parse(domain.ValuesName[0]);
            return setting.GetDefaultValue();
        }

        private static Domain UpdateLong(DomainSetting<long> setting, long value, Domain domain)
        {
            domain.Values.Clear();
            domain.Values.Add(value.ToString());
            return domain;
        }

        #endregion

        #region .int[]

        public static DomainSetting<int[]> Register(Expression<Func<DomainSetting<int[]>>> path
            , DomainDecoder<int[]> decoder = null
            , DomainEncoder<int[]> encoder = null
            , Action updated = null)
        {
            return Register(path, decoder ?? GetIntegers, encoder ?? SetIntegers, new int[0], updated);
        }

        private static int[] GetIntegers(DomainSetting<int[]> setting, Domain domain)
        {
            if (domain == null || domain.Values.Count == 0)
                return setting.GetDefaultValue();

            return domain.ValuesName.Select(int.Parse).ToArray();
        }

        private static Domain SetIntegers(DomainSetting<int[]> setting, int[] values, Domain domain)
        {
            domain.Values.Clear();
            foreach (var value in values)
                domain.Values.Add(value.ToString());
            return domain;
        }

        #endregion

        #region .Enum[]

        public static DomainSetting<TEnum[]> Register<TEnum>(Expression<Func<DomainSetting<TEnum[]>>> path
            , DomainDecoder<TEnum[]> decoder = null
            , DomainEncoder<TEnum[]> encoder = null
            , Action updated = null)
            where TEnum : struct
        {
            Check.That(typeof (TEnum).IsEnum);
            return Register(path, decoder ?? GetEnums, encoder ?? SetEnums, new TEnum[0], updated);
        }

        private static TEnum[] GetEnums<TEnum>(DomainSetting<TEnum[]> setting, Domain domain)
        {
            if (domain == null || domain.Values.Count == 0)
                return setting.GetDefaultValue();

            return domain.ValuesName.Select(EnumHelper<TEnum>.Parse).ToArray();
        }

        private static Domain SetEnums<TEnum>(DomainSetting<TEnum[]> setting, TEnum[] values, Domain domain)
        {
            domain.Values.Clear();
            foreach (var value in values)
                domain.Values.Add(value.ToString());
            return domain;
        }

        #endregion

        #region .Dictionary<string,string> // A REVOIR

        public static bool TryMap(this DomainSetting<string[]> setting, string valueToMapp, out string mappedValue)
        {
            var values = setting.Value;

            foreach (var entry in values)
            {
                if (entry == null)
                    continue;

                var pair = entry.Split(new[] { '=' });

                if (pair.Length != 2)
                    continue;

                var key = pair[0];
                var value = pair[1];

                if (key == valueToMapp
                    || (entry.StartsWith("=") && string.IsNullOrEmpty(valueToMapp))) //On traite "" et null de la meme facon, pour ce mapping il faut ajouter '=wantedValue' dans le domaine
                {
                    mappedValue = value;
                    return true;
                }
            }

            mappedValue = null;
            return false;
        }

        public static Dictionary<string, string> GetValuesAsDictionary(this DomainSetting<string[]> setting, string separator)
        {
            var dic = new Dictionary<string, string>(setting.Value.Count());
            foreach (string keyvalue in setting.Value)
            {
                string[] splitedKeyValue = keyvalue.Split(new string[] { separator }, StringSplitOptions.None);
                if (splitedKeyValue.Length == 2 && string.IsNullOrEmpty(splitedKeyValue[0]) == false)
                {
                    dic[splitedKeyValue[0]] = splitedKeyValue[1];
                }
            }
            return dic;
        }

        public static Dictionary<string, string> GetValuesAsDictionary(this DomainSetting<string[]> setting, char separator)
        {
            return setting.GetValuesAsDictionary(separator.ToString());
        }

        public static Dictionary<string, string> GetValuesAsDictionary(this DomainSetting<string[]> setting)
        {
            return setting.GetValuesAsDictionary("=");
        }

        #endregion

    }

    #region Diagnostics

    [TraceFormatter(typeof(DomainSettingTraceFormatter))]
    public interface IDomainSettingsTrace : ITraceSource
    {
        [Debug("{setting} registered ")]
        void Registered(IDomainValidator setting);

        [Info("{setting} : reading value")]
        TraceActivity ResolveSetting(IDomainValidator setting);

        [Info("{setting} : value = {value}")]
        void SettingResolved(IDomainValidator setting, object value);

        [Error("{setting} has no encoder - can't be updated via code")]
        NotImplementedException NoEncoderDefined(IDomainValidator setting);

        [Error("{setting} has IsRequired=true, but lacks value in database")]
        ConfigurationErrorsException MissingRequiredSetting(IDomainValidator setting);

        [Error("{setting} has IsRequired=true, thus deleting it is forbidden")]
        InvalidOperationException CantDeleteRequiredSetting(IDomainValidator setting);

        [Error("decoder|encoder and trueIfExists parameters are mutually exclusive, can't specify both")]
        NotSupportedException CantSpecifyBothEncoderDecodeAndTrueIfExists();
    }

    public sealed class DomainSettingTraceFormatter : TraceFormatter<IDomainValidator>
    {
        public override string Format(IDomainValidator setting)
        {
            return string.Format("Domain['{0}']", setting.Name);
        }
    }

    #endregion
}
===========================
  #region .ActivateSolstisPriceablePropertyDictionary
        [Domain("ActivateSolstisPriceablePropertyDictionary", DomainKind.Switch)]
        [Description("Activate dictionary of DynamicProperty for Solstis Priceable (size optimization)")]
        [DefaultValue(false)]
        public static readonly DomainSetting<bool> ActivateSolstisPriceablePropertyDictionary = DomainSettings.Register(() => ActivateSolstisPriceablePropertyDictionary);
        #endregion
======================================

=pp

using System;
using System.Collections;
using System.Collections.Generic;
using System.Threading;
namespace Sgcib.RiskOne.Utils
{
    // a minimalist exception for BlockingQueue exception forwarding
    [Serializable]
    public class BlockingQueueException : Exception
    {
        public BlockingQueueException()
        {
        }
        public BlockingQueueException(string message, Exception innerException)
            : base(message, innerException)
        {
        }
    }
    public class BlockingQueue<TU> : IEnumerable<TU>
    {
        protected class Data
        {
            public TU Payload;
            public Exception Exception;
            public bool EndOfEnumeration;
        }
        protected readonly ManualResetEventSlim _cancelEvent;
        public BlockingQueue(ManualResetEventSlim cancelEvent, int maxsize = Int32.MaxValue, int initialCapacity = -1)
        {
            _cancelEvent = cancelEvent;
            _semaphore = new Semaphore(0, maxsize);
            _queue = initialCapacity == -1 ? new Queue<Data>() : new Queue<Data>(initialCapacity);
        }
        protected readonly Queue<Data> _queue;
        protected readonly object _queueLock = new object();
        // do NOT use a SemaphoreSlim
        protected readonly Semaphore _semaphore;
        protected virtual void Enqueue(Data data)
        {
            lock (_queueLock)
                _queue.Enqueue(data);
            _semaphore.Release(1);
        }
        public void Enqueue(TU data)
        {
            Enqueue(new Data {Payload = data });
        }
        public void EnqueueEoe()
        {
            Enqueue(new Data { EndOfEnumeration = true });
        }
        public void EnqueueEx(Exception ex)
        {
            Enqueue(new Data { EndOfEnumeration = true, Exception = ex });
        }
        protected virtual Data DoDequeue()
        {
            Data d;
            lock (_queueLock)
                d = _queue.Dequeue();
            return d;
        }
        public IEnumerator<TU> GetEnumerator()
        {
            var whs = new[] { _semaphore, _cancelEvent.WaitHandle };
            while (true)
            {
                var dw = WaitHandle.WaitAny(whs);
                switch (dw)
                {
                    case 0:
                        var d = DoDequeue();
                        if (d.Exception != null)
                        {
                            if (d.Exception is BlockingQueueException)
                                throw new BlockingQueueException("Exception while producing a blocking queue element", d.Exception.InnerException);
                            throw new BlockingQueueException("Exception while producing a blocking queue element", d.Exception);
                        }
                        if (d.EndOfEnumeration)
                            yield break;
                        yield return d.Payload;
                        break;
                    case 1:
                        yield break;
                }
            }
        }
        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetEnumerator();
        }
    }
    // a simple queue that pop/push in a multithreaded way
    public class SizedBlockingQueue<TU> : BlockingQueue<TU>
    {
        public SizedBlockingQueue(ManualResetEventSlim cancelEvent, int maxSize = Int32.MaxValue, int initialCapacity = -1)
            : base(cancelEvent, maxSize, initialCapacity)
        {
            _spaceAvailableSemaphore = new Semaphore(maxSize, maxSize);
        }
        private readonly Semaphore _spaceAvailableSemaphore;
        protected override void Enqueue(Data data)
        {
            var whs = new [] { _spaceAvailableSemaphore, _cancelEvent.WaitHandle };
            var dw = WaitHandle.WaitAny(whs);
            switch (dw)
            {
                case 0:
                    base.Enqueue(data);
                    break;
                case 1:
                    break;
            }
        }
        protected override Data DoDequeue()
        {
            var d = base.DoDequeue();
            _spaceAvailableSemaphore.Release(1);
            return d;
        }
    }
}
===============================
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Linq.Expressions;
using System.Runtime.CompilerServices;
using System.Runtime.Serialization;
using System.ServiceModel;
using System.Text;
using System.Reflection;
using System.Collections;
using System.ComponentModel;
// ReSharper disable once CheckNamespace
namespace Sgcib.TOne.Util
{
    using Portable;
    /// <summary>
    /// Useful helper methods implemented using reflection.
    ///  - Attributes: generic extension methods for easier custom attribute querying
    ///  - Scope: helpers used in XGen.cs
    ///  - DEEP: dumps an object hierarchy to a String.
    ///  - AreIdentical compares object hierarchies field by field.
    /// </summary>
    public static class ReflectiveHelpers
    {
        static readonly char[] GenericEndChars = "`0123456789".ToCharArray();
        [DebuggerStepThrough]
        private static string GetFriendlyTypeName(Type type)
        {
            if (!type.IsGenericType)
            {
                return type.Name;
            }
            var genType = type.GetGenericTypeDefinition();
            Check.NotNull(genType);
            var sb = new StringBuilder();
            sb.Append(genType.Name.TrimEnd(GenericEndChars));
            sb.Append('<');
            var more = false;
            foreach (var argType in type.GetGenericArguments())
            {
                if (more)
                {
                    sb.Append(',');
                }
                else
                {
                    more = true;
                }
                sb.Append(GetFriendlyTypeName(argType));
            }
            sb.Append('>');
            return sb.ToString();
        }
        [DebuggerStepThrough]
        public static string GetFriendlyName(this object obj)
        {
            Check.ArgumentNotNull(obj, "obj");
            var type = obj.GetType();
            if (type.IsEnum)
            {
                return type.Name + '.' + obj;
            }
            var member = obj as MemberInfo;
            if (member != null)
            {
                type = obj as Type;
                if (type == null)
                {
                    return member.DeclaringType != null
                        ? member.DeclaringType.Name + '.' + member.Name
                        : "(null)." + member.Name
                        ;
                }
                return GetFriendlyTypeName(type);
            }
            return obj.ToString();
        }
        #region Attributes
        public static T[] GetCustomAttributes<T>(this ICustomAttributeProvider member)
            where T : Attribute
        {
            return GetCustomAttributes<T>(member, true);
        }
        public static T[] GetCustomAttributes<T>(this ICustomAttributeProvider member, bool inherit)
            where T : Attribute
        {
            return (T[])member.GetCustomAttributes(typeof(T), inherit);
        }
        public static bool HasCustomAttribute<T>(this ICustomAttributeProvider member)
            where T : Attribute
        {
            var attrs = member.GetCustomAttributes(typeof(T), true);
            return (attrs.Length != 0);
        }
        public static bool TryGetCustomAttribute<T, TAttribute>(this T obj, out TAttribute attribute)
            where TAttribute : Attribute
        {
            var type = typeof(T);
            var prov = type.IsEnum
                             ? EnumHelper<T>.MemberCache[obj]
                             : obj as ICustomAttributeProvider;
            if (prov != null)
            {
                var attrs = prov.GetCustomAttributes(typeof(TAttribute), true);
                switch (attrs.Length)
                {
                    case 0:
                        attribute = default(TAttribute);
                        return false;
                    case 1:
                        attribute = (TAttribute)attrs[0];
                        return true;
                }
            }
            throw new NotSupportedException();
        }
        public static bool TryGetCustomAttribute<TAttribute>(this Type type, out TAttribute attribute)
            where TAttribute : Attribute
        {
            if (type != null)
            {
                var attrs = type.GetCustomAttributes(typeof(TAttribute), false);
                if (!attrs.Any())
                {
                    attrs = type.GetCustomAttributes(typeof(TAttribute), true);
                }
                switch (attrs.Length)
                {
                    case 0:
                        attribute = default(TAttribute);
                        return false;
                    case 1:
                        attribute = (TAttribute)attrs[0];
                        return true;
                }
            }
            throw new NotSupportedException();
        }
#if NET45
#else
        public static TAttribute GetCustomAttribute<TAttribute>(this MemberInfo member)
            where TAttribute : Attribute
        {
            return member.GetCustomAttribute<MemberInfo, TAttribute>();
        }
#endif
        public static TAttribute GetCustomAttribute<T, TAttribute>(this T obj)
            where TAttribute : Attribute
        {
            Check.ArgumentNotNull(obj, "obj");
            TAttribute attribute;
            if (!TryGetCustomAttribute(obj, out attribute))
                throw new NotSupportedException(string.Format("Missing [{0}] attribute on {1}"
                                                              , typeof(TAttribute).Name
                                                              , obj.GetFriendlyName()
                                                    ));
            return attribute;
        }
        #endregion
        #region Scope
        public static bool IsPublicOrNestedPublic(this Type type)
        {
            if (type.IsPublic)
                return true;
            if (type.IsNested)
                return type.IsNestedPublic && type.DeclaringType.IsPublicOrNestedPublic();
            return false;
        }
        public static bool HasPublicGetter(this PropertyInfo property)
        {
            if (!property.CanRead)
                return false;
            var method = property.GetGetMethod(true);
            if (method == null)
                return false;
            return method.IsPublic;
        }
        public static bool HasPublicSetter(this PropertyInfo property)
        {
            if (!property.CanWrite)
                return false;
            var method = property.GetSetMethod(true);
            if (method == null)
                return false;
            return method.IsPublic;
        }
        #endregion
        public static bool IsNullable(this Type type)
        {
            return !type.IsClass
                && type.IsGenericType
                && (type.GetGenericTypeDefinition() == typeof(Nullable<>));
        }
        public static Type NotRef(this Type type)
        {
            return type.IsByRef
                       ? type.GetElementType()
                       : type;
        }
        public static MethodInfo GetInterfaceMethod(this Type type, string methodName, Type[] paramTypes)
        {
            return type.GetMethod(methodName, paramTypes) ??
                   type.GetInterfaces().Select(i => i.GetMethod(methodName, paramTypes))
                       .FirstOrDefault(m => m != null);
        }
        public static MemberInfo GetMember(this Expression expression)
        {
            return ReflectionExtensions.GetMember(expression);
        }
        public static MethodInfo GetMethod(this Expression expression)
        {
            return ReflectionExtensions.GetMethod(expression);
        }
        public static Type GetDataType(this MemberInfo member)
        {
            return ReflectionExtensions.GetDataType(member);
        }
        public static TypeCode GetTypeCode(this Type type)
        {
            return Type.GetTypeCode(type);
        }
        public static TypeCode GetTypeCode(this Type type, out bool isNullable)
        {
            isNullable = (type.IsGenericType && type.GetGenericTypeDefinition() == typeof(Nullable<>));
            if (isNullable)
                type = type.GetGenericArguments()[0];
            return Type.GetTypeCode(type);
        }
        public static bool CanBeNull(this Type type, out TypeCode typeCode)
        {
            bool canBeNull;
            typeCode = GetTypeCode(type, out canBeNull);
            if (!canBeNull)
                switch (typeCode)
                {
                    case TypeCode.String:
                    case TypeCode.Object:
                        canBeNull = true;
                        break;
                }
            return canBeNull;
        }
        public static bool CanBeNull(this Type type, out Type dataType)
        {
            if (type.IsNullable())
            {
                dataType = type.GetGenericArguments()[0];
                return true;
            }
            dataType = type;
            switch (type.GetTypeCode())
            {
                case TypeCode.String:
                case TypeCode.Object:
                    return true;
                default:
                    return false;
            }
        }
        public static object GetValue(this MemberInfo member, object obj)
        {
            return ReflectionExtensions.GetValue(member, obj);
        }
        public static void SetValue(this MemberInfo member, object obj, object value)
        {
            ReflectionExtensions.SetValue(member, obj, value);
        }
        [UsedImplicitly]
// ReSharper disable once UnusedMember.Local
        private static T GetDefault<T>()
        {
            return default(T);
        }
        private static MethodInfo _getDefault;
        public static object GetDefault(Type type)
        {
            if (_getDefault == null)
                _getDefault = typeof(ReflectiveHelpers).GetMethod("GetDefault", BindingFlags.NonPublic | BindingFlags.Static, null, Type.EmptyTypes, null);
            var method = _getDefault.MakeGenericMethod(type);
            return method.Invoke(null, null);
        }
        #region WCF KnownTypes/ServiceKnownTypes
        private static IEnumerable<Type> GetKnownTypes(Type type, Type declaringType, Type attrTypeProperty, string attrMethodName)
        {
            if (attrTypeProperty != null)
                return new[] { attrTypeProperty };
            if (attrMethodName != null)
            {
                const BindingFlags flags = BindingFlags.Public |
                                           BindingFlags.NonPublic |
                                           BindingFlags.Static |
                                           BindingFlags.FlattenHierarchy |
                                           BindingFlags.InvokeMethod;
                var method = declaringType.GetMethod(attrMethodName, flags, null, Type.EmptyTypes, null);
                if (method != null)
                    return (IEnumerable<Type>)method.Invoke(null, null);
                method = declaringType.GetMethod(attrMethodName, flags, null, new[] { typeof(ICustomAttributeProvider) }, null);
                if (method != null)
                    return (IEnumerable<Type>)method.Invoke(null, new object[] { type });
                throw new MissingMethodException(declaringType.FullName, attrMethodName);
            }
            return Enumerable.Empty<Type>();
        }
        public static IEnumerable<Type> GetKnownTypes(this Type type)
        {
            return from attr in type.GetCustomAttributes<KnownTypeAttribute>()
                   from knownType in GetKnownTypes(type, type, attr.Type, attr.MethodName)
                   select knownType;
        }
        public static IEnumerable<Type> GetServiceKnownTypes(this Type type)
        {
            return from attr in type.GetCustomAttributes<ServiceKnownTypeAttribute>()
                   from knownType in GetKnownTypes(type, attr.DeclaringType ?? type, attr.Type, attr.MethodName)
                   select knownType;
        }
        #endregion
        #region Implements
        /// <summary>
        /// Indicates wether a class implements a given interface.
        /// </summary>
        /// <param name="classType">The class to check.</param>
        /// <param name="interfaceType">The interface to check with</param>
        /// <returns>true if the class implements the given interface; false otherwise.</returns>
        public static bool ImplementsInterface(this Type classType, Type interfaceType)
        {
            Check.ArgumentNotNull(classType, "classType");
            Check.ArgumentNotNull(interfaceType, "interfaceType");
            Check.Argument(interfaceType.IsInterface || interfaceType.IsAbstract);
            return interfaceType.IsAssignableFrom(classType);
        }
        /// <summary>
        /// Indicates wether a class implements a given interface.
        /// </summary>
        /// <param name="classType">The class to check.</param>
        /// <typeparam name="TInterface">The interface to check with</typeparam>
        /// <returns>true if the class implements the given interface; false otherwise.</returns>
        public static bool Implements<TInterface>(this Type classType)
        {
            return ImplementsInterface(classType, typeof(TInterface));
        }
        /// <summary>
        /// Check if a type implement a given generic (whatever the generic parameters types are)
        /// </summary>
        /// <typeparam name="TGeneric">we assume the is a generic type , this is not checked</typeparam>
        /// <param name="classType"></param>
        /// <returns></returns>
        public static bool ImplementsGeneric<TGeneric>(this Type classType)
        {
            if (classType == null)
                return false;
            if (classType.IsGenericType && classType.GetGenericTypeDefinition() == typeof(TGeneric).GetGenericTypeDefinition())
                return true;
            return ImplementsGeneric<TGeneric>(classType.BaseType);
        }
        public static bool IsGeneric(this Type type, Type genericTypeDefinition, out Type[] argumentTypes)
        {
            while (type != null && type != typeof (object))
            {
                if (type.IsGenericType && type.GetGenericTypeDefinition() == genericTypeDefinition)
                {
                    argumentTypes = type.GetGenericArguments();
                    return true;
                }
                type = type.BaseType;
            }
            argumentTypes = Type.EmptyTypes;
            return false;
        }
        public static bool IsGeneric(this Type type, Type genericTypeDefinition, out Type argumentType)
        {
            Type[] argumentTypes;
            if (type.IsGeneric(genericTypeDefinition, out argumentTypes))
            {
                argumentType = argumentTypes[0];
                return true;
            }
            argumentType = default(Type);
            return false;
        }
        #endregion
        #region DEEP
        public static String DeepToString(Object obj)
        {
            DeepToStringBuilder collector = new DeepToStringBuilder();
            DeepToString(obj, collector);
            return collector.ToString();
        }
        public static String FormatedDeepToString(Object obj)
        {
            FormatedDeepToStringBuilder collector = new FormatedDeepToStringBuilder();
            DeepToString(obj, collector);
            return collector.ToString();
        }
        interface IDeepToStringBuilder
        {
            void Append(char chr);
            void Append(String str);
            void AddTab();
            void RemoveTab();
            void EndLine();
        }
        class DeepToStringBuilder : IDeepToStringBuilder
        {
            private readonly StringBuilder _stringBuilder = new StringBuilder();
            public void Append(char chr)
            {
                _stringBuilder.Append(chr);
            }
            public void Append(String str)
            {
                _stringBuilder.Append(str);
            }
            public override string ToString()
            {
                return _stringBuilder.ToString();
            }
            public void AddTab()
            {
            }
            public void RemoveTab()
            {
            }
            public void EndLine()
            {
            }
        }
        class FormatedDeepToStringBuilder : IDeepToStringBuilder
        {
            private readonly StringBuilder _stringBuilder = new StringBuilder();
            private readonly Stack<int> _tabs = new Stack<int>();
            private bool _pendingNewLine;
            private int _currentLineLength;
            public void Append(char chr)
            {
                HandlePendingNewLine();
                _stringBuilder.Append(chr);
                _currentLineLength++;
            }
            public void Append(String str)
            {
                HandlePendingNewLine();
                _stringBuilder.Append(str);
                _currentLineLength += str.Length;
            }
            public override string ToString()
            {
                return _stringBuilder.ToString();
            }
            public void AddTab()
            {
                _tabs.Push(_currentLineLength);
            }
            public void RemoveTab()
            {
                _tabs.Pop();
            }
            public void EndLine()
            {
                _stringBuilder.AppendLine();
                _currentLineLength = 0;
                _pendingNewLine = true;
            }
            private void HandlePendingNewLine()
            {
                if (!_pendingNewLine)
                    return;
                int tabs = _tabs.Peek();
                _stringBuilder.Append(new String(' ', tabs));
                _currentLineLength += tabs;
                _pendingNewLine = false;
            }
        }
        private static void DeepToString(Object obj, IDeepToStringBuilder collector)
        {
            if (obj == null)
            {
                collector.Append("null");
            }
            else if (IsSimpleDataType(obj))
            {
                collector.Append(obj.ToString());
            }
            else if (obj is DictionaryEntry)
            {
                DeepToStringDictionaryEntry((DictionaryEntry)obj, collector);
            }
            else if (obj is IDictionary)
            {
                DeepToStringEnumerable(DictionaryToEnumerable((IDictionary)obj), collector);
            }
            else if (obj is IEnumerable)
            {
                DeepToStringEnumerable(obj as IEnumerable, collector);
            }
            else
            {
                DeepToStringSingleItem(obj, collector);
            }
        }
        private static void DeepToStringDictionaryEntry(DictionaryEntry obj, IDeepToStringBuilder collector)
        {
            DeepToString(obj.Key, collector);
            collector.Append("=>");
            DeepToString(obj.Value, collector);
        }
        private static bool IsSimpleDataType(Object obj)
        {
            return obj is Int16
                   || obj is Int32
                   || obj is Int64
                   || obj is UInt16
                   || obj is UInt32
                   || obj is UInt64
                   || obj is Boolean
                   || obj is float
                   || obj is Double
                   || obj is String
                   || obj is Enum
                   || obj is DateTime
                // XOneDate or XOneDateTime, whose definition is in an assembly we don't reference
                // no StartsWith("XOneDate") because it breaks on XOneDate[]
                   || obj.GetType().Name.Equals("XOneDateTime")
                   || obj.GetType().Name.Equals("XOneDate");
        }
        private static IEnumerable DictionaryToEnumerable(IDictionary associations)
        {
            foreach (DictionaryEntry entry in associations)
                yield return entry;
        }
        private static void DeepToStringEnumerable(IEnumerable collection, IDeepToStringBuilder collector)
        {
            Check.ArgumentNotNull(collection, "collection");
            collector.Append('[');
            collector.AddTab();
            CollectionHelper.ForEachAndBetween<object>(collection
                , () => { collector.Append(';'); collector.EndLine(); }
                , item => DeepToString(item, collector)
                );
            collector.Append(']');
            collector.RemoveTab();
        }
        private static void DeepToStringSingleItem(Object obj, IDeepToStringBuilder collector)
        {
            Check.ArgumentNotNull(obj, "obj");
            Check.Argument(!(obj is IEnumerable));
            collector.Append(obj.GetType().Name);
            collector.Append('(');
            collector.AddTab();
            bool isFirst = true;
            foreach (PropertyInfo prop in obj.GetType().GetProperties())
            {
                MethodInfo getter = prop.GetGetMethod();
                if (getter == null || getter.IsStatic)
                    continue;
                if (isFirst)
                {
                    isFirst = false;
                }
                else
                {
                    collector.Append(';');
                    collector.EndLine();
                }
                collector.Append(prop.Name);
                collector.Append('=');
                DeepToString(prop.GetValue(obj, null), collector);
            }
            foreach (FieldInfo field in obj.GetType().GetFields())
            {
                if (field.IsStatic)
                    continue;
                if (isFirst)
                {
                    isFirst = false;
                }
                else
                {
                    collector.Append(';');
                    collector.EndLine();
                }
                collector.Append(field.Name);
                collector.Append('=');
                DeepToString(field.GetValue(obj), collector);
            }
            collector.Append(')');
            collector.RemoveTab();
        }
        #endregion
        #region AreIdentical
        public static bool AreIdentical(Object objA, Object objB)
        {
            return AreIdentical(objA, objB, delegate { return false; });
        }
        public static bool AreIdentical(Object objA, Object objB, Predicate<MemberInfo> isExcluded)
        {
            return !FindDifferences(objA, objB, true, isExcluded).Any();
        }
        public static bool AreIdentical(Object objA, Object objB, params String[] excludedProperties)
        {
            var excluded = new Set<string>(excludedProperties);
            return AreIdentical(objA, objB, prop =>
            {
                Check.ArgumentNotNull(prop, "prop");
                return excluded.Contains(prop.Name);
            });
        }
        #endregion
        #region FindDifferences : similar to AreIdentical but returns the differences (optionnally only the first one)
        public enum DifferenceKind { TypeMismatch, Value, NullValue, MissingValue }
        public class ObjectDifference
        {
            public ObjectDifference(DifferenceKind kind)
            {
                Kind = kind;
            }
            public DifferenceKind Kind { get; private set; }
            public string Path { get; set; }
            public string Message { get; set; }
            public override string ToString()
            {
                var sb = new StringBuilder();
                sb.Append(Kind);
                if (!string.IsNullOrEmpty(Path))
                    sb.Append(" on ").Append(Path);
                if (!string.IsNullOrEmpty(Message))
                    sb.Append(" : ").Append(Message);
                return sb.ToString();
            }
        }
        public static IEnumerable<ObjectDifference> FindDifferences(Object objA, Object objB, bool includeFields = false)
        {
            return FindDifferences(objA, objB, false, delegate { return false; }, includeFields);
        }
        public static IEnumerable<ObjectDifference> FindDifferences(Object objA, Object objB, bool firstOnly, bool includeFields = false)
        {
            return FindDifferences(objA, objB, firstOnly, delegate { return false; }, includeFields);
        }
        public static IEnumerable<ObjectDifference> FindDifferences(Object objA, Object objB, Func<Object, Object, bool> comparer, bool firstOnly)
        {
            return FindDifferences(objA, objB, comparer, firstOnly, delegate { return false; });
        }
        public static IEnumerable<ObjectDifference> FindDifferences(Object objA, Object objB, params String[] excludedProperties)
        {
            return FindDifferences(objA, objB, false, excludedProperties);
        }
        public static IEnumerable<ObjectDifference> FindDifferences(Object objA, Object objB, bool firstOnly, params String[] excludedProperties)
        {
            var excluded = new Set<string>(excludedProperties);
            return FindDifferences(objA, objB, firstOnly, prop =>
            {
                Check.ArgumentNotNull(prop, "prop");
                return excluded.Contains(prop.Name);
            });
        }
        public static IEnumerable<ObjectDifference> FindDifferences(Object objA, Object objB, bool firstOnly, bool includeFields, params String[] excludedProperties)
        {
            var excluded = new Set<string>(excludedProperties);
            return FindDifferencesInternal(objA, objB, Equals, firstOnly, prop =>
            {
                Check.ArgumentNotNull(prop, "prop");
                return excluded.Contains(prop.Name);
            }, new Dictionary<object, HashSet<object>>(ObjectReferenceEqualityComparer.Instance), includeFields);
        }
        public static IEnumerable<ObjectDifference> FindDifferences(Object objA, Object objB, Predicate<MemberInfo> isExcluded)
        {
            return FindDifferences(objA, objB, false, isExcluded);
        }
        public class ObjectReferenceEqualityComparer : IEqualityComparer<object>
        {
            public static ObjectReferenceEqualityComparer Instance = new ObjectReferenceEqualityComparer();
            // ReSharper disable MemberHidesStaticFromOuterClass
            public new bool Equals(object x, object y) { return ReferenceEquals(x, y); }
            // ReSharper restore MemberHidesStaticFromOuterClass
            public int GetHashCode(object obj) { return RuntimeHelpers.GetHashCode(obj); }
        }
        public static IEnumerable<ObjectDifference> FindDifferences(Object objA, Object objB, bool firstOnly, Predicate<MemberInfo> isExcluded, bool includeFields = false)
        {
            return FindDifferencesInternal(objA, objB, firstOnly, isExcluded, new Dictionary<object, HashSet<object>>(ObjectReferenceEqualityComparer.Instance), includeFields);
        }
        public static IEnumerable<ObjectDifference> FindDifferences(Object objA, Object objB, Func<Object, Object, bool> comparer, bool firstOnly, Predicate<MemberInfo> isExcluded, bool includeFields = false)
        {
            return FindDifferencesInternal(objA, objB, comparer, firstOnly, isExcluded, new Dictionary<object, HashSet<object>>(ObjectReferenceEqualityComparer.Instance), includeFields);
        }
        private static IEnumerable<ObjectDifference> FindDifferencesInternal(Object objA, Object objB, bool firstOnly, Predicate<MemberInfo> isExcluded, Dictionary<object, HashSet<object>> alreadyCompared, bool includeFields = false)
        {
            return FindDifferencesInternal(objA, objB, Equals, firstOnly, isExcluded, alreadyCompared, includeFields);
        }
        private static IEnumerable<ObjectDifference> FindDifferencesInternal(Object objA, Object objB, Func<Object, Object, bool> comparer, bool firstOnly, Predicate<MemberInfo> isExcluded, Dictionary<object, HashSet<object>> alreadyCompared, bool includeFields = false)
        {
            Check.ArgumentNotNull(isExcluded, "isExcluded");
            if (objA == objB)
                yield break;
            if (objA == null || objB == null)
            {
                yield return new ObjectDifference(DifferenceKind.NullValue) { Message = string.Format("{0} != {1}", objA ?? "NULL", objB ?? "NULL") };
                yield break;
            }
            if (IsSimpleDataType(objA))
            {
                if (!comparer(objA, objB))
                    yield return new ObjectDifference(DifferenceKind.Value) { Message = string.Format("{0} != {1}", objA, objB) };
                yield break;
            }
            HashSet<object> comparedToA;
            if (!alreadyCompared.TryGetValue(objA, out comparedToA))
            {
                comparedToA = new HashSet<object>(ObjectReferenceEqualityComparer.Instance);
                alreadyCompared.Add(objA, comparedToA);
            }
            if (comparedToA.Contains(objB))
                yield break;
            comparedToA.Add(objB);
            if (objA is IDictionary)
            {
                foreach (var diff in FindDifferencesInDictionaries(objA as IDictionary, objB, firstOnly, isExcluded, alreadyCompared, includeFields))
                {
                    yield return diff;
                    if (firstOnly)
                        yield break;
                }
                yield break;
            }
            if (objA is IEnumerable)
            {
                foreach (var diff in FindDifferencesInEnumerables(objA as IEnumerable, objB, firstOnly, isExcluded, alreadyCompared, includeFields))
                {
                    yield return diff;
                    if (firstOnly)
                        yield break;
                }
                yield break;
            }
            foreach (var diff in FindDifferencesInNonNullObjects(objA, objB, firstOnly, isExcluded, alreadyCompared, includeFields))
            {
                yield return diff;
                if (firstOnly)
                    yield break;
            }
        }
        private static IEnumerable<ObjectDifference> FindDifferencesInDictionaries(IDictionary dictA, object objB, bool firstOnly, Predicate<MemberInfo> isExcluded, Dictionary<object, HashSet<object>> alreadyCompared, bool includeFields)
        {
            Check.ArgumentNotNull(dictA, "dictA");
            Check.ArgumentNotNull(objB, "objB");
            Check.ArgumentNotNull(isExcluded, "isExcluded");
            if (!(objB is IDictionary))
            {
                yield return new ObjectDifference(DifferenceKind.TypeMismatch) { Message = string.Format("{0} is not a IDictionary", objB.GetType().FullName) };
                yield break;
            }
            var dictB = (IDictionary)objB;
            foreach (var key in dictA.Keys)
            {
                if (dictB.Contains(key))
                {
                    foreach (var diff in FindDifferencesInternal(dictA[key], dictB[key], firstOnly, isExcluded, alreadyCompared, includeFields))
                    {
                        diff.Path = string.Format("[{0}]", key) + (string.IsNullOrEmpty(diff.Path) ? "" : "." + diff.Path);
                        yield return diff;
                        if (firstOnly)
                            yield break;
                    }
                }
                else
                {
                    yield return new ObjectDifference(DifferenceKind.MissingValue) { Message = string.Format("Key {0} not in second dictionary", key) };
                    if (firstOnly)
                        yield break;
                }
            }
            foreach (var key in dictB.Keys)
            {
                if (!dictA.Contains(key))
                {
                    yield return new ObjectDifference(DifferenceKind.MissingValue) { Message = string.Format("Key {0} not in first dictionary", key) };
                    if (firstOnly)
                        yield break;
                }
            }
        }
        private static IEnumerable<ObjectDifference> FindDifferencesInEnumerables(IEnumerable objA, object objB, bool firstOnly, Predicate<MemberInfo> isExcluded, Dictionary<object, HashSet<object>> alreadyCompared, bool includeFields)
        {
            Check.ArgumentNotNull(objA, "objA");
            Check.ArgumentNotNull(objB, "objB");
            Check.ArgumentNotNull(isExcluded, "isExcluded");
            if (!(objB is IEnumerable))
            {
                yield return new ObjectDifference(DifferenceKind.TypeMismatch) { Message = string.Format("{0} is not a IEnumerable", objB.GetType().FullName) };
                yield break;
            }
            var iterator1 = objA.GetEnumerator();
            var iterator2 = ((IEnumerable)objB).GetEnumerator();
            bool notFinished1 = iterator1.MoveNext();
            bool notFinished2 = iterator2.MoveNext();
            int i = 0;
            while (notFinished1 && notFinished2)
            {
                foreach (var diff in FindDifferencesInternal(iterator1.Current, iterator2.Current, firstOnly, isExcluded, alreadyCompared, includeFields))
                {
                    diff.Path = string.Format("[{0}]", i) + (string.IsNullOrEmpty(diff.Path) ? "" : "." + diff.Path);
                    yield return diff;
                    if (firstOnly)
                        yield break;
                }
                notFinished1 = iterator1.MoveNext();
                notFinished2 = iterator2.MoveNext();
                i++;
            }
            if (notFinished1 != notFinished2)
                yield return new ObjectDifference(DifferenceKind.MissingValue) { Message = (notFinished1 ? "second" : "first") + " collection is too short" };
        }
        private static IEnumerable<ObjectDifference> FindDifferencesInNonNullObjects(object objA, object objB, bool firstOnly, Predicate<MemberInfo> isExcluded, Dictionary<object, HashSet<object>> alreadyCompared, bool includeFields = false)
        {
            Check.ArgumentNotNull(objA, "objA");
            Check.ArgumentNotNull(objB, "objB");
            Check.ArgumentNotNull(isExcluded, "isExcluded");
            if (objA.GetType() != objB.GetType())
            {
                yield return new ObjectDifference(DifferenceKind.TypeMismatch) { Message = string.Format("{0} != {1}", objA.GetType().FullName, objB.GetType().FullName) };
                yield break;
            }
            Type type = objA.GetType();
            foreach (var prop in type.GetProperties())
            {
                var getter = prop.GetGetMethod();
                // getter.GetParameters().Length > 0 means this is an indexer, we can't test it here
                if (getter == null || getter.IsStatic || getter.GetParameters().Length > 0)
                    continue;
                if (isExcluded(prop))
                    continue;
                object propValueA = prop.GetValue(objA, null);
                object propValueB = prop.GetValue(objB, null);
                var customCompareAttribute = prop.GetCustomAttributes<CustomCompareAttribute>().FirstOrDefault();
                if (customCompareAttribute != null)
                {
                    if (!customCompareAttribute.Comparer(propValueA, propValueB))
                    {
                        yield return new ObjectDifference(DifferenceKind.Value) { Path = prop.Name, Message = string.Format("{0} != {1}", propValueA, propValueB) };
                        if (firstOnly)
                            yield break;
                    }
                }
                else
                {
                    foreach (var diff in FindDifferencesInternal(propValueA, propValueB, firstOnly, isExcluded, alreadyCompared, includeFields))
                    {
                        diff.Path = prop.Name + (string.IsNullOrEmpty(diff.Path) ? "" : "." + diff.Path);
                        yield return diff;
                        if (firstOnly)
                            yield break;
                    }
                }
            }
            if (includeFields)
                foreach (var field in type.GetFields())
                {
                    if (field.IsStatic || isExcluded(field))
                        continue;
                    object fieldValueA = field.GetValue(objA);
                    object fieldValueB = field.GetValue(objB);
                    var customCompareAttribute = field.GetCustomAttributes<CustomCompareAttribute>().FirstOrDefault();
                    if (customCompareAttribute != null)
                    {
                        if (!customCompareAttribute.Comparer(fieldValueA, fieldValueB))
                        {
                            yield return new ObjectDifference(DifferenceKind.Value) { Path = field.Name, Message = string.Format("{0} != {1}", fieldValueA, fieldValueB) };
                            if (firstOnly)
                                yield break;
                        }
                    }
                    else
                    {
                        foreach (var diff in FindDifferencesInternal(fieldValueA, fieldValueB, firstOnly, isExcluded, alreadyCompared, true))
                        {
                            diff.Path = field.Name + (string.IsNullOrEmpty(diff.Path) ? "" : "." + diff.Path);
                            yield return diff;
                            if (firstOnly)
                                yield break;
                        }
                    }
                }
        }
        #endregion
        #region Named property/field handling
        /// <summary>
        /// Get flat list of values by evaluating a property path (IList objects encountred are automtically enumerated and used as next path step)
        /// </summary>
        /// <param name="instance"></param>
        /// <param name="propertyPath"></param>
        /// <returns></returns>
        public static IEnumerable<object> GetEnumProperty(object instance, string propertyPath)
        {
            Check.ArgumentNotNull(instance, "instance");
            Check.ArgumentNotNull(propertyPath, "property");
            List<object> results = new List<object>(new[] { instance });
            List<object> subResults = new List<object>();
            string[] properties = propertyPath.Split('.');
            int depth = properties.Length;
            Check.That(depth > 0);
            for (int i = 0; i < depth; i++)
            {
                foreach (var resultRanki in results)
                {
                    Type type = resultRanki.GetType();
                    string property = properties[i];
                    var propertyInfo = type.GetProperty(property);
                    if (propertyInfo == null)
                        throw new Exception(string.Format("Type '{0}' has no property '{1}'.", type.Name, property));
                    var subResult = propertyInfo.GetValue(resultRanki, null);
                    if (subResult != null)
                    {
                        if (subResult is IEnumerable && !(subResult is IEnumerable<char>))
                            foreach (var item in (subResult as IEnumerable))
                                subResults.Add(item);
                        else
                            subResults.Add(subResult);
                    }
                }
                results.Clear();
                results.AddRange(subResults);
                subResults.Clear();
            }
            return results;
        }
        public static void NavigateProperty(string path, ref object instance, out PropertyInfo propertyInfo)
        {
            Check.ArgumentNotNull(path, "path");
            Check.ArgumentNotNull(instance, "instance");
            propertyInfo = null;
            string[] properties = path.Split('.');
            int depth = properties.Length;
            Check.That(depth > 0);
            for (int i = 0; i < depth; i++)
            {
                Type type = instance.GetType();
                string property = properties[i];
                propertyInfo = type.GetProperty(property);
                if (propertyInfo == null)
                {
                    string msg = string.Format("Type '{0}' has no property '{1}'.",
                        type.Name, property);
                    throw new Exception(msg);
                }
                if (i < depth - 1)
                {
                    instance = propertyInfo.GetValue(instance, null);
                    if (instance == null)
                    {
                        string msg = string.Format("Cannot navigate below property '{0}' in path '{1}' because it is null.",
                            property, path);
                        throw new NullReferenceException(msg);
                    }
                }
            }
        }
        public static object GetProperty(object instance, string property)
        {
            Check.ArgumentNotNull(instance, "instance");
            Check.ArgumentNotNull(property, "property");
            PropertyInfo propertyInfo;
            NavigateProperty(property, ref instance, out propertyInfo);
            object value = propertyInfo.GetValue(instance, null);
            return value;
        }
        public static void SetProperty(object instance, string property, object value)
        {
            Check.ArgumentNotNull(instance, "instance");
            Check.ArgumentNotNull(property, "property");
            PropertyInfo propertyInfo;
            NavigateProperty(property, ref instance, out propertyInfo);
            propertyInfo.SetValue(instance, value, null);
        }
        public static void SetStaticProperty(Type type, string property, object value)
        {
            Check.ArgumentNotNull(type, "type");
            Check.ArgumentNotNull(property, "property");
            PropertyInfo propertyInfo = type.GetProperty(property, BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static);
            propertyInfo.SetValue(null, value, null);
        }
        public static void SetPropertyFromString(object instance, PropertyInfo propertyInfo, string value)
        {
            Check.ArgumentNotNull(propertyInfo, "propertyInfo");
            Type propertyType = propertyInfo.PropertyType;
            if (propertyType == typeof(string))
            {
                propertyInfo.SetValue(instance, value, null);
            }
            else
            {
                TypeConverter converter = TypeDescriptor.GetConverter(propertyType);
// ReSharper disable once ConditionIsAlwaysTrueOrFalse
                if (converter == null || !converter.CanConvertFrom(typeof(string)))
                {
                    string msg = string.Format("Found no type converter to convert from 'string' to '{0}' for property '{1}' of '{2}'.",
                        propertyType.Name,
                        propertyInfo.Name,
                        instance.GetType().Name);
                    throw new Exception(msg);
                }
                object convertedValue = converter.ConvertFromInvariantString(value);
                propertyInfo.SetValue(instance, convertedValue, null);
            }
        }
        public static void SetPropertyFromString(object instance, string property, string value)
        {
            Check.ArgumentNotNull(instance, "instance");
            Check.ArgumentNotNull(property, "property");
            PropertyInfo propertyInfo;
            NavigateProperty(property, ref instance, out propertyInfo);
            SetPropertyFromString(instance, propertyInfo, value);
        }
        public static object GetField(object instance, string fieldName, bool flattenHierarchy = false)
        {
            Check.ArgumentNotNull(instance, "instance");
            Check.ArgumentNotNullOrEmptyString(fieldName, "fieldName");
            FieldInfo fieldInfo = null;
             Type type = instance.GetType();
            while (fieldInfo == null && type!=null)
            {
                fieldInfo = type.GetField(fieldName, BindingFlags.Instance | BindingFlags.NonPublic);
                if (fieldInfo == null )
                {
                    if (flattenHierarchy)
                    {
                        type = type.BaseType;
                    }
                    else
                    {
                        break;
                    }
                }
            }
            if (fieldInfo == null)
            {
                string msg = string.Format("Type '{0}' has no field '{1}'.", type.Name, fieldName);
                throw new Exception(msg);
            }
            object value = fieldInfo.GetValue(instance);
            return value;
        }
        public static void SetField(object instance, string fieldName, object value)
        {
            Check.ArgumentNotNull(instance, "instance");
            Check.ArgumentNotNullOrEmptyString(fieldName, "fieldName");
            Type type = instance.GetType();
            FieldInfo fieldInfo = type.GetField(fieldName, BindingFlags.Instance | BindingFlags.NonPublic);
            if (fieldInfo == null)
            {
                string msg = string.Format("Type '{0}' has no field '{1}'.",
                    type.Name, fieldName);
                throw new Exception(msg);
            }
            fieldInfo.SetValue(instance, value);
        }
        public static void SetStaticField(Type type, string fieldName, object value)
        {
            Check.ArgumentNotNull(type, "type");
            Check.ArgumentNotNullOrEmptyString(fieldName, "fieldName");
            var fieldInfo = type.GetField(fieldName, BindingFlags.Static | BindingFlags.NonPublic | BindingFlags.Public);
            if (fieldInfo == null)
            {
                var msg = string.Format("Type '{0}' has no field '{1}'.", type.Name, fieldName);
                throw new Exception(msg);
            }
            fieldInfo.SetValue(null, value);
        }
        public static PropertyInfo[] GetPublicProperties(this Type type, bool hasGetAccessor)
        {
            if (hasGetAccessor)
            {
                var propertyInfos = new List<PropertyInfo>();
                foreach (PropertyInfo propertyInfo in GetPublicProperties(type))
                {
                    if (propertyInfo.HasPublicGetter())
                    {
                        propertyInfos.Add(propertyInfo);
                    }
                }
                return propertyInfos.ToArray();
            }
            return GetPublicProperties(type);
        }
        public static PropertyInfo[] GetPublicProperties(this Type type)
        {
            if (type.IsInterface)
            {
                var propertyInfos = new List<PropertyInfo>();
                var considered = new List<Type>();
                var queue = new Queue<Type>();
                considered.Add(type);
                queue.Enqueue(type);
                while (queue.Count > 0)
                {
                    var subType = queue.Dequeue();
                    foreach (var subInterface in subType.GetInterfaces())
                    {
                        if (considered.Contains(subInterface)) continue;
                        considered.Add(subInterface);
                        queue.Enqueue(subInterface);
                    }
                    var typeProperties = subType.GetProperties();
                    var newPropertyInfos = typeProperties
                        .Where(x => !propertyInfos.Contains(x));
                    propertyInfos.InsertRange(0, newPropertyInfos);
                }
                return propertyInfos.ToArray();
            }
            return type.GetProperties();
        }
        public static PropertyInfo[] GetPublicPropertiesWithoutStatic(this Type type, bool hasGetAccessor)
        {
            var properties = GetPublicProperties(type, hasGetAccessor);
            return (properties.Where(pi => !pi.GetGetMethod().IsStatic).ToArray());
        }
        /// <summary>
        /// Returns the base types of the specified type.
        /// </summary>
        /// <param name="type">Type.</param>
        /// <returns>Base types of the specified type.</returns>
        /// <exception cref="ArgumentNullException"><paramref name="type"/> is <see langword="null"/>.</exception>
        public static IEnumerable<Type> GetBaseTypes(this Type type)
        {
            if (type == null)
                throw new ArgumentNullException("type");
            var baseType = type.BaseType;
            while (baseType != null)
            {
                yield return baseType;
                baseType = baseType.BaseType;
            }
        }
        /// <summary>
        /// Returns the member info (<see cref="MemberInfo"/>) of the member of type <typeparamref name="TMember"/> of the object of type <typeparamref name="T"/> in the specified expression.
        /// </summary>
        /// <typeparam name="T">Type of the object for which we want a <see cref="MemberInfo"/>.</typeparam>
        /// <typeparam name="TMember">Type of the member for which we want a <see cref="MemberInfo"/>.</typeparam>
        /// <param name="expression">Expression specifying a member of type <typeparamref name="TMember"/> of an object of type <typeparamref name="T"/>.</param>
        /// <returns>Member info (<see cref="MemberInfo"/>) of the member of type <typeparamref name="TMember"/> of the object of type <typeparamref name="T"/> in the specified expression.</returns>
        public static MemberInfo GetMemberInfo<T, TMember>(Expression<Func<T, TMember>> expression)
        {
            if (expression == null) throw new ArgumentNullException("expression");
            var memberExpression = expression.Body as MemberExpression;
            if (memberExpression == null) throw new ArgumentException("expression.Body must be a MemberExpression.", "expression");
            return memberExpression.Member;
        }
        public static PropertyInfo GetPropertyInfo<T, TValue>(
             Expression<Func<T, TValue>> selector) where T : class
        {
            var result = GetMemberInfo(selector);
            if (result is PropertyInfo)
                return (PropertyInfo) result;
            throw new InvalidCastException("Fail to get property on type " + typeof(T).FullName + " selector's body is not of property access type");
        }
        /// <summary>
        /// Invoke a method from a class instance with given arguments
        /// </summary>
        /// <param name="instance">Class instance</param>
        /// <param name="methodName">Method name</param>
        /// <param name="args">Method arguments</param>
        /// <returns>Method return value</returns>
        public static Object InvokeMethod(Object instance, string methodName, params Object[] args)
        {
            Check.ArgumentNotNull(instance, "instance");
            var methodInfo = instance.GetType().GetMethod(methodName,
                BindingFlags.Static | BindingFlags.Instance | BindingFlags.NonPublic);
            Check.NotNull(methodInfo, String.Format("Type {0} has no method {1}", instance.GetType(), methodName));
            return methodInfo.Invoke(instance, args);
        }
        #endregion
    }
    /// <summary>
    /// Inspired by MbUnit Reflector, with a number of compatible calls
    /// </summary>
    public static class Reflector
    {
        private static FieldInfo GetFieldInfo(object obj, string name)
        {
            FieldInfo fieldInfo = null;
            Type type = obj.GetType();
            while (fieldInfo == null && type != null)
            {
                fieldInfo = type.GetField(name, BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.Static);
                type = type.BaseType;
            }
            if (fieldInfo == null)
                throw new MissingFieldException(obj.GetType().FullName, name);
            return fieldInfo;
        }
        private static PropertyInfo GetPropertyInfo(object obj, string name)
        {
            PropertyInfo propertyInfo = null;
            Type type = obj.GetType();
            while (propertyInfo == null && type != null)
            {
                propertyInfo = type.GetProperty(name, BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.Static);
                type = type.BaseType;
            }
            if (propertyInfo == null)
                throw new MissingMemberException(obj.GetType().FullName, name);
            return propertyInfo;
        }
        public static object GetField(object obj, string name)
        {
            return GetFieldInfo(obj, name).GetValue(obj);
        }
        public static void SetField(object obj, string name, object value)
        {
            GetFieldInfo(obj, name).SetValue(obj, value);
        }
        public static object GetProperty(object obj, string name)
        {
            return GetPropertyInfo(obj, name).GetValue(obj);
        }
        public static void SetProperty(object obj, string name, object value)
        {
            GetPropertyInfo(obj, name).SetValue(obj, value);
        }
        public static object InvokeMethod(object obj, string methodName, params object[] methodParams)
        {
            return InvokeMethod(obj, null, methodName, methodParams);
        }
        public static object InvokeStaticMethod(Type type, string methodName, params object[] methodParams)
        {
            return InvokeMethod(null, type, methodName, methodParams);
        }
        private static object InvokeMethod(object obj, Type type, string methodName, params object[] methodParams)
        {
            Type[] types;
            if (methodParams != null)
                types = methodParams.Select(o => o.GetType()).ToArray();
            else
                types = new Type[0];
            MethodInfo methodInfo = null;
            Type currentType = obj == null ? type : obj.GetType();
            while (methodInfo == null && currentType != null)
            {
                methodInfo = currentType.GetMethod(methodName, BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.Static, null, types, null);
                currentType = currentType.BaseType;
            }
            if (methodInfo == null)
                throw new MissingMethodException((obj == null ? type : obj.GetType()).FullName, methodName);
            return methodInfo.Invoke(obj, methodParams);
        }
    }
}
==========================
using System;
using System.Collections.Generic;
using System.Diagnostics;
namespace Sgcib.TOne.Util
{
    /// <summary>
    /// Assert style error detection with exceptions.
    /// </summary>
    [DebuggerNonUserCode]
    public static class Check
    {
        private const int DefaultNestedCalls = 1;
        [AssertionMethod]
        public static void Fail(String message)
        {
            That(false, message, DefaultNestedCalls);
        }
        [AssertionMethod]
        public static void That([AssertionCondition(AssertionConditionType.IS_TRUE)]bool condition)
        {
            That(condition, DefaultNestedCalls);
        }
        [AssertionMethod]
        public static void That([AssertionCondition(AssertionConditionType.IS_TRUE)]bool condition, String message)
        {
            That(condition, message, DefaultNestedCalls);
        }
        [AssertionMethod]
        public static void That([AssertionCondition(AssertionConditionType.IS_TRUE)]bool condition, Func<string> messager)
        {
            That<InvalidOperationException>(condition,messager,DefaultNestedCalls);
        }
        private static void That<T>(bool condition, Func<string> messager, int nestedCalls)
        {
            if (condition)
                return;
            string message = messager();
            throw (Exception)Activator.CreateInstance(typeof(T), LocatedMessage(message, nestedCalls + 1));
        }
        [AssertionMethod]
        public static T Found<T>([AssertionCondition(AssertionConditionType.IS_NOT_NULL)]object key, T obj) where T : class
        {
            That(obj != null, String.Format("{0} '{1}' not found.", typeof(T).FullName, key));
            return obj;
        }
        [AssertionMethod]
        public static void That<T>([AssertionCondition(AssertionConditionType.IS_TRUE)]bool condition, String message) where T : Exception
        {
            That<T>(condition, message, DefaultNestedCalls);
        }
        [AssertionMethod]
        public static void NotNullOrEmptyString([AssertionCondition(AssertionConditionType.IS_NOT_NULL)]String str)
        {
            That(!string.IsNullOrEmpty(str), DefaultNestedCalls);
        }
        [AssertionMethod]
        public static void NotNullOrEmptyString([AssertionCondition(AssertionConditionType.IS_NOT_NULL)]String str, String message)
        {
            That(!String.IsNullOrEmpty(str), message, DefaultNestedCalls);
        }
        [AssertionMethod]
        public static void Null([AssertionCondition(AssertionConditionType.IS_NULL)]Object obj)
        {
            Null(obj, DefaultNestedCalls);
        }
        [AssertionMethod]
        public static void Null([AssertionCondition(AssertionConditionType.IS_NULL)]Object obj, String message)
        {
            Null(obj, message, DefaultNestedCalls);
        }
        [AssertionMethod]
        public static void IsNullOrEmpty([AssertionCondition(AssertionConditionType.IS_NULL)]String s)
        {
            NullOrEmpty(s, DefaultNestedCalls);
        }
        [AssertionMethod]
        public static void IsNullOrEmpty([AssertionCondition(AssertionConditionType.IS_NULL)]String s, String message)
        {
            NullOrEmpty(s, message, DefaultNestedCalls);
        }
        [AssertionMethod]
        public static void NotNull([AssertionCondition(AssertionConditionType.IS_NOT_NULL)]Object obj)
        {
            NotNull(obj, DefaultNestedCalls);
        }
        [AssertionMethod]
        public static void NotNull([AssertionCondition(AssertionConditionType.IS_NOT_NULL)]Object obj, String message)
        {
            NotNull(obj, message, DefaultNestedCalls);
        }
        [AssertionMethod]
        public static void NotNull([AssertionCondition(AssertionConditionType.IS_NOT_NULL)]object obj, Func<string> messager)
        {
            NotNull(obj,messager,DefaultNestedCalls);
        }
        [AssertionMethod]
        private static void NotNull([AssertionCondition(AssertionConditionType.IS_NOT_NULL)]object o, Func<string> messager, int calls)
        {
               if (o == null)
                throw new InvalidOperationException(LocatedMessage(messager(), calls + 1));
        }
        [AssertionMethod]
        public static void NotNullNorEmpty([AssertionCondition(AssertionConditionType.IS_NOT_NULL)]Object obj, String message)
        {
            if ((obj == null) || ((obj is string) && ((string)obj).Length == 0))
            {
                Fail(message);
            }
        }
        [AssertionMethod]
        public static void NotNull([AssertionCondition(AssertionConditionType.IS_NOT_NULL)]Object propertyValue, String propertyName, Object container)
        {
            NotNull(propertyValue, String.Format("No value for {0} in {1}.", propertyName, container));
        }
        [AssertionMethod]
        public static void NotNullNorEmpty([AssertionCondition(AssertionConditionType.IS_NOT_NULL)]Object propertyValue, String propertyName, Object container)
        {
            NotNullNorEmpty(propertyValue, String.Format("No value for {0} in {1}.", propertyName, container));
        }
        [AssertionMethod]
        public static void NotNullNorEmpty([AssertionCondition(AssertionConditionType.IS_NOT_NULL)]Object container, string propertyNames, params Object[] propertyValues)
        {
            string[] parts = propertyNames.Split(',');
            System.Text.StringBuilder builder = null;
            for (int i = 0; i < propertyValues.Length; i++)
            {
                if ((propertyValues[i] == null) || ((propertyValues[i] is string) && ((string)(propertyValues[i])).Length == 0))
                {
                    if (builder == null)
                    {
                        builder = new System.Text.StringBuilder();
                        builder.Append("In ");
                        builder.Append(container.ToString());
                        builder.Append(", missing value for: ");
                        builder.Append(parts[i]);
                    }
                    else
                    {
                        builder.Append(", ");
                        builder.AppendLine(parts[i]);
                    }
                }
            }
            if (builder != null) Fail(builder.ToString());
        }
        [AssertionMethod]
        public static void Argument([AssertionCondition(AssertionConditionType.IS_TRUE)]bool condition)
        {
            Argument(condition, DefaultNestedCalls);
        }
        [AssertionMethod]
        public static void Argument([AssertionCondition(AssertionConditionType.IS_TRUE)]bool condition, String message)
        {
            Argument(condition, message, DefaultNestedCalls);
        }
        [AssertionMethod]
        public static void Argument([AssertionCondition(AssertionConditionType.IS_TRUE)]bool condition, String message, String argumentName)
        {
            Argument(condition, message, argumentName, DefaultNestedCalls);
        }
        [AssertionMethod]
        public static void ArgumentNotNull([AssertionCondition(AssertionConditionType.IS_NOT_NULL)]Object obj, String argumentName)
        {
            ArgumentNotNull(obj, argumentName, DefaultNestedCalls);
        }
        [AssertionMethod]
        public static void ArgumentNotNullOrEmptyString([AssertionCondition(AssertionConditionType.IS_NOT_NULL)]string argument, string argumentName)
        {
            ArgumentNotNull(argument, argumentName, DefaultNestedCalls);
            Argument(argument != string.Empty, String.Format("Invalid value for the argument \"{0}\". Value must not be an empty string.", argumentName), argumentName, DefaultNestedCalls);
        }
        public static T OrWrapException<E, T>(String exceptionMessage, Func<T> doSomething) where E : Exception
        {
            T result = default(T);
            OrWrapException<E>(exceptionMessage, delegate
            {
                result = doSomething();
            });
            return result;
        }
        public static void OrWrapException<E>(String exceptionMessage, Handler doSomething) where E : Exception
        {
            try
            {
                doSomething();
            }
            catch (Exception e)
            {
                throw (Exception)Activator.CreateInstance(typeof(E), exceptionMessage, e);
            }
        }
        #region private implementation
        private static void That(bool condition, int nestedCalls)
        {
            That(condition, "Assertion failed.", nestedCalls + 1);
        }
        private static void That(bool condition, String message, int nestedCalls)
        {
            That<InvalidOperationException>(condition, message, nestedCalls + 1);
        }
        private static void That<T>(bool condition, String message, int nestedCalls) where T : Exception
        {
            if (!condition)
            {
                throw (Exception)Activator.CreateInstance(typeof(T), LocatedMessage(message, nestedCalls + 1));
            }
        }
        private static void Null(Object obj, int nestedCalls)
        {
            Null(obj, "Unexpected not null object.", nestedCalls + 1);
        }
        private static void Null(Object obj, String message, int nestedCalls)
        {
            That(null == obj, message, nestedCalls + 1);
        }
        private static void NullOrEmpty(String s, String message, int nestedCalls)
        {
            That(string.IsNullOrEmpty(s), message, nestedCalls + 1);
        }
        private static void NullOrEmpty(String s, int nestedCalls)
        {
            NullOrEmpty(s, "Unexpected not empty string", nestedCalls + 1);
        }
        private static void NotNull(Object obj, int nestedCalls)
        {
            NotNull(obj, "Unexpected null object.", nestedCalls + 1);
        }
        private static void NotNull(Object obj, String message, int nestedCalls)
        {
            if (null == obj)
                throw new InvalidOperationException(LocatedMessage(message, nestedCalls + 1));
        }
        private static void Argument(bool condition, int nestedCalls)
        {
            Argument(condition, "Invalid argument.", nestedCalls + 1);
        }
        private static void Argument(bool condition, String message, int nestedCalls)
        {
            if (!condition)
                throw new ArgumentException(LocatedMessage(message, nestedCalls + 1));
        }
        private static void Argument(bool condition, String message, String argumentName, int nestedCalls)
        {
            if (!condition)
                throw new ArgumentException(LocatedMessage(message, nestedCalls + 1), argumentName);
        }
        private static void ArgumentNotNull(Object obj, String argumentName, int nestedCalls)
        {
            if (null == obj)
                throw new ArgumentNullException(argumentName, LocatedMessage("Unexpected null argument.", nestedCalls + 1));
        }
        private static String LocatedMessage(String message, int nestedCalls)
        {
            // two frames are removed from the stack to
            StackTrace stack = new StackTrace(nestedCalls + 1, true);
            StackFrame caller = stack.GetFrame(0);
            return String.Format("{0} in {1} at {2}:{3}", message, caller.GetMethod(), caller.GetFileName(), caller.GetFileLineNumber());
        }
        #endregion
        public static void NotNullOrEmptyString(string str, Func<string> messager)
        {
            That(!String.IsNullOrEmpty(str), messager);
        }
    }
    #region Resharper Annotations
    /// <summary>
    /// Indicates that marked method builds string by format pattern and (optional) arguments.
    /// Parameter, which contains format string, should be given in constructor.
    /// The format string should be in <see cref="string.Format(IFormatProvider,string,object[])"/> -like form
    /// </summary>
    [AttributeUsage(AttributeTargets.Constructor | AttributeTargets.Method, AllowMultiple = false, Inherited = true)]
    public sealed class StringFormatMethodAttribute : Attribute
    {
        private readonly string myFormatParameterName;
        /// <summary>
        /// Initializes new instance of StringFormatMethodAttribute
        /// </summary>
        /// <param name="formatParameterName">Specifies which parameter of an annotated method should be treated as format-string</param>
        public StringFormatMethodAttribute(string formatParameterName)
        {
            myFormatParameterName = formatParameterName;
        }
        /// <summary>
        /// Gets format parameter name
        /// </summary>
        public string FormatParameterName
        {
            get { return myFormatParameterName; }
        }
    }
    /// <summary>
    /// Indicates that the function argument should be string literal and match one  of the parameters of the caller function.
    /// For example, <see cref="ArgumentNullException"/> has such parameter.
    /// </summary>
    [AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false, Inherited = true)]
    public sealed class InvokerParameterNameAttribute : Attribute
    {
    }
    /// <summary>
    /// Indicates that the marked method is assertion method, i.e. it halts control flow if one of the conditions is satisfied.
    /// To set the condition, mark one of the parameters with <see cref="AssertionConditionAttribute"/> attribute
    /// </summary>
    /// <seealso cref="AssertionConditionAttribute"/>
    [AttributeUsage(AttributeTargets.Method, AllowMultiple = false, Inherited = true)]
    public sealed class AssertionMethodAttribute : Attribute
    {
    }
    /// <summary>
    /// Indicates the condition parameter of the assertion method.
    /// The method itself should be marked by <see cref="AssertionMethodAttribute"/> attribute.
    /// The mandatory argument of the attribute is the assertion type.
    /// </summary>
    /// <seealso cref="AssertionConditionType"/>
    [AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false, Inherited = true)]
    public sealed class AssertionConditionAttribute : Attribute
    {
        private readonly AssertionConditionType myConditionType;
        /// <summary>
        /// Initializes new instance of AssertionConditionAttribute
        /// </summary>
        /// <param name="conditionType">Specifies condition type</param>
        public AssertionConditionAttribute(AssertionConditionType conditionType)
        {
            myConditionType = conditionType;
        }
        /// <summary>
        /// Gets condition type
        /// </summary>
        public AssertionConditionType ConditionType
        {
            get { return myConditionType; }
        }
    }
    /// <summary>
    /// Specifies assertion type. If the assertion method argument satisifes the condition, then the execution continues.
    /// Otherwise, execution is assumed to be halted
    /// </summary>
    public enum AssertionConditionType
    {
        /// <summary>
        /// Indicates that the marked parameter should be evaluated to true
        /// </summary>
        IS_TRUE = 0,
        /// <summary>
        /// Indicates that the marked parameter should be evaluated to false
        /// </summary>
        IS_FALSE = 1,
        /// <summary>
        /// Indicates that the marked parameter should be evaluated to null value
        /// </summary>
        IS_NULL = 2,
        /// <summary>
        /// Indicates that the marked parameter should be evaluated to not null value
        /// </summary>
        IS_NOT_NULL = 3,
    }
    /// <summary>
    /// Indicates if authentication is required to invoke a method.
    /// By default, authentication is required.
    /// </summary>
    [AttributeUsage(AttributeTargets.Method | AttributeTargets.Property, AllowMultiple = false, Inherited = true)]
    public sealed class RequiresAuthenticationAttribute : Attribute
    {
        /// <summary>
        /// Authentication is required to invoke the method if this property is <c>true</c>.
        /// </summary>
        /// <remarks>Default value is <c>true</c>.</remarks>
        public Boolean Value { get; set; }
        public RequiresAuthenticationAttribute(Boolean value)
        {
            Value = value;
        }
    }
    /// <summary>
    /// Indicates that the marked method unconditionally terminates control flow execution.
    /// For example, it could unconditionally throw exception
    /// </summary>
    [AttributeUsage(AttributeTargets.Method, AllowMultiple = false, Inherited = true)]
    public sealed class TerminatesProgramAttribute : Attribute
    {
    }
    /// <summary>
    /// Indicates that the value of marked element could be <c>null</c> sometimes, so the check for <c>null</c> is necessary before its usage
    /// </summary>
    [AttributeUsage(AttributeTargets.Method | AttributeTargets.Parameter | AttributeTargets.Property | AttributeTargets.Delegate | AttributeTargets.Field, AllowMultiple = false, Inherited = true)]
    public sealed class CanBeNullAttribute : Attribute
    {
    }
    /// <summary>
    /// Indicates that the value of marked element could never be <c>null</c>
    /// </summary>
    [AttributeUsage(AttributeTargets.Method | AttributeTargets.Parameter | AttributeTargets.Property | AttributeTargets.Delegate | AttributeTargets.Field, AllowMultiple = false, Inherited = true)]
    public sealed class NotNullAttribute : Attribute
    {
    }
    /// <summary>
    /// Indicates that the value of marked type (or its derivatives) cannot be compared using '==' or '!=' operators.
    /// There is only exception to compare with <c>null</c>, it is permitted
    /// </summary>
    [AttributeUsage(AttributeTargets.Interface | AttributeTargets.Class | AttributeTargets.Struct, AllowMultiple = false, Inherited = true)]
    public sealed class CannotApplyEqualityOperatorAttribute : Attribute
    {
    }
    /// <summary>
    /// When applied to target attribute, specifies a requirement for any type which is marked with
    /// target attribute to implement or inherit specific type or types
    /// </summary>
    /// <example>
    /// <code>
    /// [BaseTypeRequired(typeof(IComponent)] // Specify requirement
    /// public class ComponentAttribute : Attribute
    /// {}
    ///
    /// [Component] // ComponentAttribute requires implementing IComponent interface
    /// public class MyComponent : IComponent
    /// {}
    /// </code>
    /// </example>
    [AttributeUsage(AttributeTargets.Class, AllowMultiple = true, Inherited = true)]
    [BaseTypeRequired(typeof(Attribute))]
    //[CLSCompliant(false)]
    public sealed class BaseTypeRequiredAttribute : Attribute
    {
        private readonly Type[] myBaseTypes;
        /// <summary>
        /// Initializes new instance of BaseTypeRequiredAttribute
        /// </summary>
        /// <param name="baseTypes">Specifies which types are required</param>
        public BaseTypeRequiredAttribute(params Type[] baseTypes)
        {
            myBaseTypes = baseTypes;
        }
        /// <summary>
        /// Gets enumerations of specified base types
        /// </summary>
        public IEnumerable<Type> BaseTypes
        {
            get { return myBaseTypes; }
        }
    }
    /// <summary>
    /// Indicates that the marked symbol is used implicitly (ex. reflection, external library), so this symbol will not be marked as unused (as well as by other usage inspections)
    /// </summary>
    [AttributeUsage(AttributeTargets.All, AllowMultiple = false, Inherited = false)]
    [MeansImplicitUse]
    public class UsedImplicitlyAttribute : Attribute
    {
    }
    /// <summary>
    /// Should be used on attributes and causes ReSharper to not mark symbols marked with such attributes as unused (as well as by other usage inspections)
    /// </summary>
    [AttributeUsage(AttributeTargets.Class, AllowMultiple = false, Inherited = true)]
    public class MeansImplicitUseAttribute : Attribute
    {
        private ImplicitUseFlags myFlags;
        [UsedImplicitly]
        public ImplicitUseFlags Flags
        {
            get { return myFlags; }
            private set { myFlags = value; }
        }
        [UsedImplicitly]
        public MeansImplicitUseAttribute()
            : this(ImplicitUseFlags.STANDARD)
        {
        }
        [UsedImplicitly]
        public MeansImplicitUseAttribute(ImplicitUseFlags flags)
        {
            Flags = flags;
        }
    }
    [Flags]
    public enum ImplicitUseFlags
    {
        STANDARD = 0,
        ALL_MEMBERS_USED = 1
    }
    /// <summary>
    /// Tells code analysis engine if the parameter is completely handled
    /// when the invoked method is on stack. If the parameter is a delegate,
    /// indicates that delegate is executed while the method is executed.
    /// If the parameter is an enumerable, indicates that it is enumerated
    /// while the method is executed
    /// </summary>
    [AttributeUsage(AttributeTargets.Parameter, Inherited = true)]
    public sealed class InstantHandleAttribute : Attribute { }
    #endregion
}
==================================================




using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Linq;
using System.Runtime.Serialization.Formatters.Binary;
using System.Text;
using Sgcib.TOne.Util.IO;
namespace Sgcib.TOne.Util
{
    /// <summary>
    /// Various helper methods to manipulate collections.
    /// </summary>
    public static class CollectionHelper
    {
        public static string Flatten<T>(this IEnumerable<T> sequence, string separator, Func<int, T, string> toString)
        {
            bool first = true;
            int i = 0;
            var result = new StringBuilder();
            foreach (var item in sequence)
            {
                if (!first)
                    result.Append(separator);
                if (first)
                {
                    first = false;
                }
                result.Append(toString(i, item));
                i++;
            }
            return result.ToString();
        }
        public static string Flatten<T>(this IEnumerable<T> sequence, string separator, Func<T, string> toString)
        {
            return Flatten(sequence, separator, (i, item) => toString(item));
        }
        public static void Each<T>(this IEnumerable<T> sequence, Action<T> action)
        {
            foreach (var item in sequence)
                action(item);
        }
        public static void Each<T>(this IEnumerable<T> sequence, Action<int, T> action)
        {
            int index = 0;
            foreach (var item in sequence)
            {
                action(index, item);
                index++;
            }
        }
        public static int Walk(this IEnumerable source)
        {
            var count = 0;
            var e = source.GetEnumerator();
            var d = e as IDisposable;
            if (d != null)
                using (d)
                    while (e.MoveNext())
                        count++;
            else
                while (e.MoveNext())
                    count++;
            return count;
        }
        public static IEnumerable<T> CloneAll<T>(this IEnumerable<T> source)
            where T : ICloneable<T>
        {
            return source.Select(item => item.Clone());
        }
        public static T AddTo<T>(this T item, ref Queue<T> queue)
        {
            if (queue == null)
                queue = new Queue<T>();
            queue.Enqueue(item);
            return item;
        }
        public static T AddTo<T>(this T item, ref List<T> list)
        {
            if (list == null)
                list = new List<T>();
            list.Add(item);
            return item;
        }
        public static T RemoveFrom<T>(this T item, ref List<T> list)
        {
            if (list.Remove(item))
                if (list.Count == 0)
                    list = null;
            return item;
        }
        public static T AddTo<T>(this T item, ref Stack<T> stack)
        {
            if (stack == null)
                stack = new Stack<T>();
            stack.Push(item);
            return item;
        }
        /// <summary>
        /// Return chunks from an enumeration , goupsize can be 0, or negative , or Int32.Max : this will return only one chunk
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="enumerable"></param>
        /// <param name="groupSize"></param>
        /// <returns></returns>
        public static IEnumerable<List<T>> SafeChunk<T>(this IEnumerable<T> enumerable, int groupSize)
        {
            // The list to return.
            List<T> list = new List<T>();
            // Cycle through all of the items.
            foreach (T item in enumerable)
            {
                // Add the item.
                list.Add(item);
                // If the list has the number of elements, return that.
                if (list.Count == groupSize)
                {
                    // Return the list.
                    yield return list;
                    // Set the list to a new list.
                    list = new List<T>();
                }
            }
            // Return the remainder if there is any,
            if (list.Count != 0)
            {
                // Return the list.
                yield return list;
            }
        }
        public static IEnumerable<List<T>> Chunk<T>(this IEnumerable<T> enumerable, int groupSize)
        {
            Check.That(groupSize > 0, () => "Invalid group size " + groupSize);
            // The list to return.
            List<T> list = new List<T>(groupSize);
            // Cycle through all of the items.
            foreach (T item in enumerable)
            {
                // Add the item.
                list.Add(item);
                // If the list has the number of elements, return that.
                if (list.Count == groupSize)
                {
                    // Return the list.
                    yield return list;
                    // Set the list to a new list.
                    list = new List<T>(groupSize);
                }
            }
            // Return the remainder if there is any,
            if (list.Count != 0)
            {
                // Return the list.
                yield return list;
            }
        }
        public static TOut[] CastArray<TIn, TOut>(this TIn[] input)
            where TOut : TIn
        {
            var output = new TOut[input.Length];
            for (var i = 0; i < input.Length; i++)
                output[i] = (TOut)input[i];
            return output;
        }
        public static TOut[] ConvertAll<TIn, TOut>(this TIn[] input, Func<TIn, TOut> convert)
        {
            var output = new TOut[input.Length];
            for (var i = 0; i < input.Length; i++)
                output[i] = convert(input[i]);
            return output;
        }
        public static IEnumerable<T> Concat<T>(this IEnumerable<T> source, params T[] second)
        {
            return Enumerable.Concat(source, second);
        }
        public static IEnumerable<T> Except<T>(this IEnumerable<T> source, params T[] second)
        {
            return Enumerable.Except(source, second);
        }
        public static string[] ToArray(this StringCollection coll)
        {
            var array = new string[coll.Count];
            coll.CopyTo(array, 0);
            return array;
        }
        public static HashSet<T> ToHashSet<T>(this IEnumerable<T> source)
        {
            return new HashSet<T>(source.Distinct());
        }
        public static HashSet<T> AddRange<T>(this HashSet<T> hashSet, IEnumerable<T> range)
        {
            foreach (T toAdd in range)
                hashSet.Add(toAdd);
            return hashSet;
        }
        public static IEnumerable<string> StringJoinSplit(this IEnumerable<string> source, string separator, int maxlength)
        {
            Check.ArgumentNotNull(source, "source");
            Check.ArgumentNotNull(separator, "separator");
            Check.That(maxlength > 0, "maxlength");
            var separatorLength = separator.Length;
            var remainingItems = source.StringJoin(separator);
            var remainingItemsLength = remainingItems.Length;
            while (remainingItemsLength >= maxlength)
            {
                var splitPos = remainingItems.LastIndexOf(separator, maxlength, maxlength, StringComparison.Ordinal);
                if (splitPos == -1)
                    break;
                if (splitPos == 0)
                {
                    remainingItems = remainingItems.Substring(separatorLength);
                    continue;
                }
                var nextItemsToSend = remainingItems.Substring(0, splitPos);
                yield return nextItemsToSend;
                var remainingItemsPos = splitPos + separatorLength;
                remainingItems = (remainingItemsLength > remainingItemsPos) ? remainingItems.Substring(remainingItemsPos) : string.Empty;
                remainingItemsLength = remainingItems.Length;
            }
            if (!string.IsNullOrEmpty(remainingItems))
                yield return remainingItems;
        }
        public static List<List<T>> Split<T>(this IList<T> list, Func<T, bool> isSpliiter, bool removeSplitter = true)
        {
            var skip = removeSplitter ? 1 : 0;
            var counter = 0;
            // add empty element at start for using .Skip(1) at first group
            if (removeSplitter)
                list = new[] { default(T) }
                    .Concat(list)
                    .ToList();
            return list
                // add Index to each group
                .Select(c => new { Index = isSpliiter(c) ? ++counter : counter, Value = c })
                // group
                .GroupBy(pair => pair.Index)
                // transform each group to list and remove splitter if needed
                .Select(sub => sub.Select(c => c.Value).Skip(skip).ToList())
                .ToList();
        }
        public static List<T> Join<T>(this IList<List<T>> data, T splitter = default(T), bool putSplitter = false)
        {
            var splitterArr = new List<T>();
            if (putSplitter)
                splitterArr.Add(splitter);
            return data
                .SelectMany(line => splitterArr.Concat(line))
                .Skip(putSplitter ? 1 : 0)
                .ToList();
        }
        public static IEnumerable<T> SkipLast<T>(this IEnumerable<T> source, int n)
        {
            Queue<T> buffer = new Queue<T>(n + 1);
            foreach (T x in source)
            {
                buffer.Enqueue(x);
                if (buffer.Count == n + 1)
                {
                    yield return buffer.Dequeue();
                }
            }
        }
        public static string Plural(this string single)
        {
            var l = single.Length;
            switch (char.ToLowerInvariant(single[l - 1]))
            {
                case 'y':
                    return single.Substring(0, l - 1) + "ies";
                default:
                    return single + 's';
            }
        }
        public static bool IsNullOrNoneOrEmpty(this string str)
        {
            return string.IsNullOrEmpty(str) || str == RuntimeConstants.None;
        }
        public static T[] Merge<T>(this T[] first, params T[][] arrays)
        {
            var length = first.Length + arrays.Sum(array => array.Length);
            var result = new T[length];
            length = first.Length;
            Array.Copy(first, 0, result, 0, first.Length);
            foreach (var array in arrays)
            {
                Array.Copy(array, 0, result, length, array.Length);
                length += array.Length;
            }
            return result;
        }
        /// <summary>
        /// Returns distinct elements from a sequence according to a specified key selector function.
        /// </summary>
        /// <typeparam name="TSource">The type of the elements of source.</typeparam>
        /// <typeparam name="TKey">The type of the key returned by keySelector.</typeparam>
        /// <param name="source">The sequence to remove duplicate elements from.</param>
        /// <param name="keySelector">A function to extract the key for each element.</param>
        /// <returns>An <see cref="IEnumerable{T}"/> that contains distinct elements from the source sequence.</returns>
        public static IEnumerable<TSource> DistinctBy<TSource, TKey>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector)
        {
            if (source == null) throw new ArgumentNullException("source");
            if (keySelector == null) throw new ArgumentNullException("keySelector");
            return source.Distinct().GroupBy(keySelector).Select(group => group.First());
        }
        /// <summary>
        /// Produces the set difference of a sequence and a sequence generated using the specified item by using the default equality comparer to compare values.
        /// </summary>
        /// <typeparam name="TSource">The type of the elements of the input sequences.</typeparam>
        /// <param name="this">An <see cref="System.Collections.Generic.IEnumerable{T}"/> whose elements that are not also in second will be returned.</param>
        /// <param name="item">An item of type <typeparamref name="TSource"/> which, should it occur in the first sequence; will cause those elements to be removed from the returned sequence.</param>
        /// <returns>A sequence that contains the set difference of the elements of the specified sequence and a sequence built with the specified item.</returns>
        /// <exception cref="ArgumentNullException"><paramref name="this"/> or <paramref name="item"/> is <see langword="null"/>.</exception>
        public static IEnumerable<TSource> Except<TSource>(this IEnumerable<TSource> @this, TSource item)
        {
            if (@this == null) throw new ArgumentNullException("this");
            return @this.Except(new[] { item });
        }
        /// <summary>
        /// Returns the specified sequence with its items shuffled.
        /// </summary>
        /// <typeparam name="TSource">The type of the elements of the input sequences.</typeparam>
        /// <param name="this">The sequence which items will be shuffled.</param>
        /// <returns>Specified sequence with its items shuffled.</returns>
        /// <exception cref="ArgumentNullException"><paramref name="this"/> is <see langword="null"/>.</exception>
        /// <remarks>Due to the very nature of shuffling, this method does not use deferred execution.</remarks>
        public static IEnumerable<TSource> Shuffle<TSource>(this IEnumerable<TSource> @this)
        {
            if (@this == null) throw new ArgumentNullException("this");
            return @this.Shuffle(new Random());
        }
        /// <summary>
        /// Returns the specified sequence with its items shuffled using the specified random number generator.
        /// </summary>
        /// <typeparam name="TSource">The type of the elements of the input sequences.</typeparam>
        /// <param name="this">The sequence which items will be shuffled.</param>
        /// <param name="random">The random number generator used to shuffle the input sequence items.</param>
        /// <returns>Specified sequence with its items shuffled.</returns>
        /// <exception cref="ArgumentNullException"><paramref name="this"/> or <paramref name="random"/> is <see langword="null"/>.</exception>
        /// <remarks>Due to the very nature of shuffling, this method does not use deferred execution.</remarks>
        public static IEnumerable<TSource> Shuffle<TSource>(this IEnumerable<TSource> @this, Random random)
        {
            if (@this == null) throw new ArgumentNullException("this");
            if (random == null) throw new ArgumentNullException("random");
            var buffer = @this.ToList();
            for (var i = 0; i < buffer.Count; i++)
            {
                var j = random.Next(i, buffer.Count);
                yield return buffer[j];
                buffer[j] = buffer[i];
            }
        }
        /// <summary>
        /// Returns a dictionary of key value pairs built upon the specified sequence of such key value pairs (<see cref="KeyValuePair{T, U}"/>).
        /// </summary>
        /// <typeparam name="TKey">The type of the keys.</typeparam>
        /// <typeparam name="TValue">The type of the values.</typeparam>
        /// <param name="this">The sequence which will be converted to a dictionary.</param>
        /// <returns>Dictionary of key value pairs built upon the specified sequence of such key value pairs (<see cref="KeyValuePair{T, U}"/>)..</returns>
        /// <exception cref="ArgumentNullException"><paramref name="this"/> is <see langword="null"/>.</exception>
        /// <exception cref="ArgumentException"><paramref name="this"/> contains several instances of a key.</exception>
        /// <remarks>As we need to check if keys are unique, this method does not used deferred execution.</remarks>
        public static IDictionary<TKey, TValue> ToDictionary<TKey, TValue>(this IEnumerable<KeyValuePair<TKey, TValue>> @this)
        {
            if (@this == null) throw new ArgumentNullException("this");
            @this = @this.ToArray();
            if (@this.Select(kvp => kvp)
                     .GroupBy(kvp => kvp.Key)
                     .Any(kvpGroup => kvpGroup.Count() > 1))
            {
                throw new ArgumentException("the specified sequence contains several instances of a key", "this");
            }
            return @this.ToDictionary(kvp => kvp.Key, kvp => kvp.Value);
        }
        public static void RemoveAll<TKey, TValue>(this IDictionary<TKey, TValue> dic, Func<TKey, bool> filter)
        {
            var keys = dic.Keys.Where(filter).ToList();
            foreach (var key in keys)
            {
                dic.Remove(key);
            }
        }
        public delegate bool Comparer<T>(T item1, T item2);
        /// <summary>
        /// From a list like [a,b,c] constructs a list [f(a),f(b),f(c)]
        /// </summary>
        public static List<R> Map<T, R>(IEnumerable<T> items, Func<T, R> functor)
        {
            var result = new List<R>();
            foreach (T item in items)
            {
                result.Add(functor(item));
            }
            return result;
        }
        public static List<R> SafeMap<T, R>(IEnumerable<T> items, Func<T, R> functor)
        {
            var result = new List<R>();
            foreach (T item in items)
            {
                try
                {
                    result.Add(functor(item));
                }
                catch
                {
                }
            }
            return result;
        }
        /// <summary>
        /// From a collection like [a,b,c] constructs an array [f(a),f(b),f(c)]
        /// </summary>
        public static R[] MapToArray<T, R>(ICollection<T> items, Func<T, R> functor)
        {
            var result = new R[items.Count];
            var i = 0;
            foreach (T item in items)
            {
                result[i++] = functor(item);
            }
            return result;
        }
        /// <summary>
        /// From a list like [a,b,c] constructs a dictionary like [f(a) => a, f(b) => b, f(c) => c]
        /// </summary>
        public static Dictionary<K, T> Index<K, T>(IEnumerable<T> items, Func<T, K> extractKey)
        {
            var result = new Dictionary<K, T>();
            foreach (T item in items)
            {
                result.Add(extractKey(item), item);
            }
            return result;
        }
        public static List<R> RecursivSuite<R, T>(IEnumerable<T> indexes, Func<R, T, R> next, R firstValue)
        {
            var result = new List<R> { firstValue };
            R previousValue = firstValue;
            foreach (T index in indexes)
            {
                R newValue = next(previousValue, index);
                result.Add(newValue);
                previousValue = newValue;
            }
            return result;
        }
        public static void ForEachPair<T>(IEnumerable<T> items, Handler<T, T> doSomething)
        {
            Check.ArgumentNotNull(items, "items");
            Check.ArgumentNotNull(doSomething, "doSomething");
            IEnumerator<T> enumerator = items.GetEnumerator();
            enumerator.Reset();
            if (!enumerator.MoveNext())
                return;
            T previous = enumerator.Current;
            while (enumerator.MoveNext())
            {
                doSomething(previous, enumerator.Current);
                previous = enumerator.Current;
            }
        }
        public static T FindFirst<T>(IEnumerable<T> items, Predicate<T> predicate)
        {
            foreach (T item in items)
            {
                if (predicate(item))
                    return item;
            }
            return default(T);
        }
        public static Dictionary<K, T> Clone<K, T>(IDictionary<K, T> dico)
        {
            Check.Argument(dico is IDictionary);
            var copy = new Dictionary<K, T>();
            CopyTo(dico, copy);
            return copy;
        }
        public static void CopyTo<K, T>(IDictionary<K, T> from, IDictionary<K, T> to)
        {
            Check.ArgumentNotNull(from, "from");
            Check.ArgumentNotNull(to, "to");
            foreach (KeyValuePair<K, T> pair in from)
            {
                to[pair.Key] = pair.Value;
            }
        }
        public static Dictionary<K, T> DeepCloneCloneableOfT<K, T>(IDictionary<K, T> dico)
            where K : ICloneable<K>
            where T : ICloneable<T>
        {
            Check.Argument(dico is IDictionary);
            var copy = new Dictionary<K, T>();
            DeepCopyToCloneableOfT(dico, copy);
            return copy;
        }
        public static void DeepCopyToCloneableOfT<K, T>(IDictionary<K, T> from, IDictionary<K, T> to)
            where K : ICloneable<K>
            where T : ICloneable<T>
        {
            Check.ArgumentNotNull(from, "from");
            Check.ArgumentNotNull(to, "to");
            foreach (KeyValuePair<K, T> pair in from)
            {
                to[pair.Key.Clone()] = pair.Value.Clone();
            }
        }
        public static Dictionary<K, T> DeepCloneCloneable<K, T>(IDictionary<K, T> dico)
            where K : ICloneable
            where T : ICloneable
        {
            Check.Argument(dico is IDictionary);
            var copy = new Dictionary<K, T>();
            DeepCopyToCloneable(dico, copy);
            return copy;
        }
        public static void DeepCopyToCloneable<K, T>(IDictionary<K, T> from, IDictionary<K, T> to)
            where K : ICloneable
            where T : ICloneable
        {
            Check.ArgumentNotNull(from, "from");
            Check.ArgumentNotNull(to, "to");
            foreach (KeyValuePair<K, T> pair in from)
            {
                to[(K)pair.Key.Clone()] = (T)pair.Value.Clone();
            }
        }
        // From http://www.codeproject.com/KB/recipes/DeepCloneDictionary.aspx
        //
        /// <summary>
        /// Creates a copy of a dictionary by serializing and deserializing it.
        /// </summary>
        /// <remarks>Objects must be serializable (See <see cref="SerializableAttribute"/>)</remarks>
        public static Dictionary<K, V> DeepCloneDictionaryBySerialization<K, V>(IEnumerable<KeyValuePair<K, V>> dict)
        {
            // The clone method is immune to the source dictionary being null.
            if (dict == null)
                return null;
            // If the key and value are value types, clone without serialization.
            if (((typeof(K).IsValueType || typeof(K) == typeof(string)) &&
                 (typeof(V).IsValueType) || typeof(V) == typeof(string)))
            {
                var result = new Dictionary<K, V>();
                // Clone by copying the value types.
                foreach (var kvp in dict)
                {
                    result[kvp.Key] = kvp.Value;
                }
                return result;
            }
            // Clone by serializing to a memory stream, then deserializing.
            // Don't use this method if you've got a large objects, as the
            // BinaryFormatter produces bloat, bloat, and more bloat.
            var formatter = new BinaryFormatter();
            using (var stream = new PooledMemoryStream())
            {
                formatter.Serialize(stream, dict);
                stream.Position = 0;
                var result = (Dictionary<K, V>)formatter.Deserialize(stream);
                return result;
            }
        }
        public static void TransformTo<K, T, U>(IDictionary<K, T> from, IDictionary<K, U> to, Func<T, U> transform)
        {
            Check.ArgumentNotNull(from, "from");
            Check.ArgumentNotNull(to, "to");
            foreach (KeyValuePair<K, T> pair in from)
            {
                to[pair.Key] = transform(pair.Value);
            }
        }
        public static ISet<K> Clone<K>(ISet<K> set)
        {
            ISet<K> copy = new Set<K>();
            foreach (K k in set)
            {
                copy.Add(k);
            }
            return copy;
        }
        public static bool AreEqual(IEnumerable list1, IEnumerable list2)
        {
            return AreEqual(list1, list2, Equals);
        }
        public static bool AreEqual(IEnumerable list1, IEnumerable list2, Comparer<Object> itemsAreEqual)
        {
            if (list1 == list2)
                return true;
            if ((null == list1) || (null == list2))
                return false;
            IEnumerator iterator1 = list1.GetEnumerator();
            IEnumerator iterator2 = list2.GetEnumerator();
            try
            {
                iterator1.Reset();
            }
            catch (NotSupportedException)
            {
                // Some iterators (e.g. ErrorsList iterator) do not support Reset():
                // Just assume GetEnumerator() returns an iterator at the beginning.
            }
            try
            {
                iterator2.Reset();
            }
            catch (NotSupportedException)
            {
                // Some iterators (e.g. ErrorsList iterator) do not support Reset():
                // Just assume GetEnumerator() returns an iterator at the beginning.
            }
            bool notFinished1 = iterator1.MoveNext();
            bool notFinished2 = iterator2.MoveNext();
            while (notFinished1 && notFinished2)
            {
                if (!itemsAreEqual(iterator1.Current, iterator2.Current))
                    return false;
                notFinished1 = iterator1.MoveNext();
                notFinished2 = iterator2.MoveNext();
            }
            return (notFinished1 == notFinished2);
        }
        public static bool AreEqualUnordered<T>(IEnumerable<T> list1, IEnumerable<T> list2)
        {
            if (list1 == list2)
                return true;
            if ((null == list1) || (null == list2))
                return false;
            var left = new List<T>(list1);
            foreach (T t in list2)
            {
                int index = left.IndexOf(t);
                if (index < 0)
                {
                    return false;
                }
                else
                {
                    left.RemoveAt(index);
                }
            }
            return (left.Count == 0);
        }
        public static bool AreEqualUnordered(IEnumerable list1, IEnumerable list2)
        {
            if (list1 == list2)
                return true;
            if ((null == list1) || (null == list2))
                return false;
            var left = new List<object>();
            foreach (var obj in list1)
            {
                left.Add(obj);
            }
            foreach (var obj in list2)
            {
                int index = left.IndexOf(obj);
                if (index < 0)
                {
                    return false;
                }
                else
                {
                    left.RemoveAt(index);
                }
            }
            return (left.Count == 0);
        }
        /// <summary>
        ///  Quadratic function, do not compare too big lists
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="list1"></param>
        /// <param name="list2"></param>
        /// <param name="comparer"></param>
        /// <returns></returns>
        public static bool AreEqualUnordered<T>(IEnumerable<T> list1, IEnumerable<T> list2, Comparer<T> comparer)
        {
            if (ReferenceEquals(list1, list2))
                return true;
            if ((null == list1) || (null == list2))
                return false;
            var left = new List<T>(list1);
            foreach (T t2 in list2)
            {
                bool found = false;
                for (int i = 0; i < left.Count; ++i)
                {
                    if (comparer(t2, left[i]))
                    {
                        found = true;
                        left.RemoveAt(i);
                        break;
                    }
                }
                if (!found)
                    return false;
            }
            return (left.Count == 0);
        }
        public static bool AreDictionariesEqual<K, T>(IDictionary<K, T> dico1, IDictionary<K, T> dico2)
        {
            return AreDictionariesEqual(dico1, dico2, (v1, v2) => Equals(v1, v2));
        }
        public static bool AreDictionariesEqual<K, T>(IDictionary<K, T> dico1, IDictionary<K, T> dico2, Comparer<T> valuesAreEqual)
        {
            if (dico1 == dico2)
                return true;
            if (dico1 == null || dico2 == null || dico1.Count != dico2.Count)
                return false;
            foreach (var entry in dico1)
            {
                T value2;
                if (!dico2.TryGetValue(entry.Key, out value2))
                    return false;
                if (!valuesAreEqual(entry.Value, value2))
                    return false;
            }
            return true;
        }
        public static bool AreDictionariesEqual<K, T>(IDictionary<K, IList<T>> dico1, IDictionary<K, IList<T>> dico2)
        {
            return AreDictionariesEqual(dico1, dico2, AreEqual);
        }
        public const String NULL_OBJECT_TO_STRING = "nothing";
        public static void ForEachAndBetween<T>(IEnumerable values, Handler betweenAction, Action<T> action)
        {
            Check.ArgumentNotNull(action, "action");
            Check.ArgumentNotNull(betweenAction, "betweenAction");
            if (null == values)
                return;
            var isFirstItem = true;
            foreach (T value in values)
            {
                if (isFirstItem)
                {
                    isFirstItem = false;
                }
                else
                {
                    betweenAction();
                }
                action(value);
            }
        }
        public delegate String ToStringDelegate<T>(T obj);
        public static String ToString<T>(IEnumerable values, String prefix, string between, ToStringDelegate<T> itemToString, String suffix)
        {
            if (null == values)
                return NULL_OBJECT_TO_STRING;
            var result = new StringBuilder();
            result.Append(prefix);
            ForEachAndBetween<T>(values
                                 , () => result.Append(between)
                                 , value => result.Append(itemToString(value))
                );
            result.Append(suffix);
            return result.ToString();
        }
        public static String ToString(IEnumerable values, String prefix, string between, String suffix)
        {
            return ToString<Object>(values, prefix, between, obj => obj.ToString(), suffix);
        }
        public static String ToString<T>(IEnumerable values, ToStringDelegate<T> itemToString)
        {
            return ToString(values, "[", ";", itemToString, "]");
        }
        public static String ToString(IEnumerable values)
        {
            return ToString<object>(values
                                    , value => (value == null ? "" : value.ToString())
                );
        }
        public static String ToString<K, T>(IDictionary<K, T> keyValues, ToStringDelegate<T> valueToString)
        {
            Check.ArgumentNotNull(valueToString, "valueToString");
            return ToString<KeyValuePair<K, T>>(keyValues
                                                , keyValue => keyValue.Key + "=>" + valueToString(keyValue.Value)
                );
        }
        public static String ToString<K, T>(IDictionary<K, T> keyValues)
        {
            return ToString(keyValues, obj => obj.ToString());
        }
        public static String ToString<K, T>(IDictionary<K, IList<T>> keyValues)
        {
            return ToString(keyValues, delegate(IList<T> obj)
            {
                return ToString(obj);
            });
        }
        public static bool Contains<T>(IEnumerable<T> values, Predicate<T> predicate)
        {
            foreach (T value in values)
            {
                if (predicate(value))
                    return true;
            }
            return false;
        }
        public static T[] ToArray<T>(ICollection<T> collection)
        {
            return ToArrayOf<T, T>(collection);
        }
        public static T[] ToArrayOf<T, U>(ICollection<U> collection) where T : U
        {
            var result = new T[collection.Count];
            var i = 0;
            foreach (U item in collection)
            {
                result[i] = (T)item;
                i++;
            }
            return result;
        }
        /// <summary>
        /// Iterates simultaneously over two lists, calling a delegate on each pair.
        /// </summary>
        /// <throws>ArgumentException if the two lists have different lengthes</throws>
        public static void Foreach<T, U>(ICollection<T> list1, ICollection<U> list2, Handler<T, U> doSomething)
        {
            Check.ArgumentNotNull(list1, "list1");
            Check.ArgumentNotNull(list2, "list2");
            Check.Argument(list1.Count == list2.Count);
            IEnumerator<T> enum1 = list1.GetEnumerator();
            enum1.Reset();
            IEnumerator<U> enum2 = list2.GetEnumerator();
            enum2.Reset();
            while (enum1.MoveNext() && enum2.MoveNext())
            {
                doSomething(enum1.Current, enum2.Current);
            }
        }
        /// <summary>
        /// Add foreach with an index as parameter
        /// http://stackoverflow.com/questions/521687/c-sharp-foreach-with-index
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="ie"></param>
        /// <param name="action"></param>
        public static void ForEach<T>(this IEnumerable<T> ie, Action<T, int> action)
        {
            var i = 0;
            foreach (var e in ie) action(e, i++);
        }
        public static void ForEach<T>(this IEnumerable<T> ie, Action<T> action)
        {
            foreach (var e in ie) action(e);
        }
        public static IEnumerable<U> Enumerate<T, U>(IEnumerable<T> list, Predicate<T> predicate)
            where U : class
        {
            Check.ArgumentNotNull(list, "List");
            IEnumerator<T> enumerator = list.GetEnumerator();
            while (enumerator.MoveNext())
            {
                T current = enumerator.Current;
                if (predicate(current))
                    yield return current as U;
            }
        }
        public static IEnumerable<IEnumerable<T>> EnumerateByBucket<T>(IEnumerable<T> items, int bucketSize)
        {
            Check.ArgumentNotNull(items, "items");
            var subList = new List<T>(bucketSize);
            IEnumerator<T> enumerator = items.GetEnumerator();
            do
            {
                subList.Clear();
                subList.AddRange(Enumerate(enumerator, bucketSize));
                if (subList.Count == 0)
                    yield break;
                yield return subList;
            }
            while (subList.Count > 0);
        }
        private static IEnumerable<T> Enumerate<T>(IEnumerator<T> enumerator, int maxEnumerable)
        {
            int i = 0;
            while (i < maxEnumerable && enumerator.MoveNext())
            {
                T current = enumerator.Current;
                yield return current;
                i++;
            }
        }
        public static T FirstOf<T>(IEnumerable<T> items)
        {
            Check.ArgumentNotNull(items, "items");
            IEnumerator<T> enumerator = items.GetEnumerator();
            enumerator.Reset();
            if (!enumerator.MoveNext())
                throw new ArgumentException("Collection is empty", "items");
            T result = enumerator.Current;
            return result;
        }
        public static ICollection<T> Intersection<T>(ICollection<T> list1, ICollection<T> list2)
        {
            var result = new List<T>();
            foreach (T item in list1)
            {
                if (list2.Contains(item))
                {
                    result.Add(item);
                }
            }
            return result;
        }
        public static IEnumerable<T> Intersection<T>(this ICollection<T> @this, ICollection<T> otherList, Func<T, T, bool> compare)
        {
            foreach (T item in @this)
            {
                if (otherList.Any(otherItemm => compare(item, otherItemm)))
                {
                    yield return item;
                }
            }
        }
        public static ICollection<T> Minus<T>(ICollection<T> listSource, ICollection<T> listRemove)
        {
            var result = new List<T>(listSource);
            foreach (T item in listSource)
            {
                if (listRemove.Contains(item))
                {
                    result.Remove(item);
                }
            }
            return result;
        }
        public static ICollection<T> GetChangedItems<T, TKey>(ICollection<T> newList, ICollection<T> oldList, Func<T, TKey> getKey, out ICollection<T> newItems, out ICollection<T> deletedItems)
        {
            Check.NotNull(newList);
            Check.NotNull(oldList);
            Dictionary<TKey, T> oldItemsDict = new Dictionary<TKey, T>(oldList.Count);
            foreach (T item in oldList)
            {
                TKey key = getKey(item);
                if (oldItemsDict.ContainsKey(key))
                    throw new InvalidOperationException("Old list of objects containing a duplicated key " + key);
                oldItemsDict[getKey(item)] = item;
            }
            Set<TKey> notDeletedKeys = new Set<TKey>();
            ICollection<T> result = new List<T>();
            newItems = new List<T>();
            T foundOldItem;
            // fill new item
            foreach (T newItem in newList)
            {
                TKey keyNewItem = getKey(newItem);
                notDeletedKeys.Add(keyNewItem);
                if (oldItemsDict.TryGetValue(keyNewItem, out foundOldItem))
                {
                    if (!foundOldItem.Equals(newItem))
                    {
                        result.Add(newItem);
                    }
                }
                else
                {
                    newItems.Add(newItem);
                }
            }
            // fill deleted itmes list
            deletedItems = new List<T>();
            foreach (var oldKey in oldItemsDict.Keys)
            {
                if (!notDeletedKeys.Contains(oldKey))
                {
                    deletedItems.Add(oldItemsDict[oldKey]);
                }
            }
            return result;
        }
        public static ICollection<T> Union<T>(ICollection<T> list1, ICollection<T> list2)
        {
            var result = new Set<T>();
            foreach (T item in list1)
            {
                result.Add(item);
            }
            foreach (T item in list2)
            {
                result.Add(item);
            }
            return new List<T>(result);
        }
        public static bool CheckAreEquals<T>(IEnumerable<T> set1, IEnumerable<T> set2, Comparer<T> comparer, Handler<T> onItemMissingInSet1, Handler<T> onItemMissingInSet2)
        {
            var ok = true;
            ok &= CheckContains(set2, set1, comparer, onItemMissingInSet1);
            ok &= CheckContains(set1, set2, comparer, onItemMissingInSet2);
            return ok;
        }
        public static bool CheckContains<T>(IEnumerable<T> set, IEnumerable<T> subSet)
            where T : class
        {
            return CheckContains(set, subSet, delegate(T item1, T item2)
            {
                if (item1 == null || item2 == null)
                    return (item1 == null && item2 == null);
                return item1.Equals(item2);
            }, null);
        }
        public static bool CheckContains<T>(IEnumerable<T> set, IEnumerable<T> subSet, Comparer<T> comparer, Handler<T> onItemMissingInSet)
        {
            if (set == null || subSet == null)
                return (set == null && subSet == null);
            var ok = true;
            foreach (T item1 in subSet)
            {
                var found = false;
                foreach (T item2 in set)
                {
                    if (comparer(item1, item2))
                    {
                        found = true;
                        break;
                    }
                }
                if (!found)
                {
                    ok = false;
                    if (onItemMissingInSet != null)
                        onItemMissingInSet(item1);
                }
            }
            return ok;
        }
        /// <summary>
        ///
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="list"></param>
        /// <param name="comparer"></param>
        /// <param name="OnDuplicateEntryFound">return true if entry is removed from the list, false otherwise</param>
        /// <param name="OnNewItemProcessed">can be null</param>
        public static void SearchDuplicateEntries<T>(IList<T> list, Comparer<T> comparer, Func<Int32, T, Boolean> OnDuplicateEntryFound, Handler<Int32, T> OnNewItemProcessed)
        {
            int i = 0;
            while (i < list.Count)
            {
                T item = list[i];
                if (OnNewItemProcessed != null)
                    OnNewItemProcessed(i, item);
                // Not very optimized but the list is large so it takes care of memory usage like ..
                int j = i + 1;
                while (j < list.Count)
                {
                    T itemBis = list[j];
                    if (comparer(item, itemBis))
                    {
                        if (OnDuplicateEntryFound(j, itemBis))
                            continue;
                    }
                    j++;
                }
                i++;
            }
        }
        public static bool Contains(this IEnumerable<string> target, string value, StringComparison comparisonType)
        {
            return target.Any(item => item.Equals(value, comparisonType));
        }
        public static int IndexOfOrMax<T>(this IList<T> @this, T item)
        {
            return @this.IndexOfOrDefault(item, int.MaxValue);
        }
        public static int IndexOfOrDefault<T>(this IList<T> @this, T item, int defaultValue)
        {
            var index = @this.IndexOf(item);
            return index == -1 ? defaultValue : index;
        }
        /* Algorithm by Donald Knuth. */
        /// <summary>
        /// Get combination of k element from a list of elements
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="list"></param>
        /// <param name="k"></param>
        /// <returns></returns>
        public static IList<List<T>> GetCombinationsOf_k<T>(IList<T> list, int k)
        {
            Check.NotNull(list);
            Check.That(k >= 0);
            IList<List<T>> result = new List<List<T>>();
            if (k == 0)
                return result;
            if (k == list.Count)
            {
                result.Add(new List<T>(list));
                return result;
            }
            int i, j, x;
            var c = new int[k + 3];
            int n = list.Count;
            for (i = 1; i <= k; i++) c[i] = i;
            c[k + 1] = n + 1;
            c[k + 2] = 0;
            j = k;
        visit:
            var combination = new List<T>();
            for (i = k; i >= 1; i--)
            {
                combination.Add(list[c[i] - 1]);
            }
            result.Add(combination);
            if (j > 0) { x = j + 1; goto incr; }
            if (c[1] + 1 < c[2])
            {
                c[1] += 1;
                goto visit;
            }
            j = 2;
        do_more:
            c[j - 1] = j - 1;
            x = c[j] + 1;
            if (x == c[j + 1]) { j++; goto do_more; }
            if (j > k) return result;
        incr:
            c[j] = x;
            j--;
            goto visit;
        }
        public static void MergeDictionary<T, U>(Dictionary<T, U> mergeTarget, Dictionary<T, U> itemsToMerge)
        {
            Check.NotNull(mergeTarget);
            Check.NotNull(itemsToMerge);
            foreach (var keyValue in itemsToMerge)
            {
                mergeTarget[keyValue.Key] = keyValue.Value;
            }
        }
        public static List<List<T>> SplitInListOfList<T>(IEnumerable<T> listToSplit, int blockSize)
        {
            Check.NotNull(listToSplit);
            Check.That(blockSize > 0);
            List<List<T>> listOfSplittedList = new List<List<T>>();
            int lotSize = blockSize;
            List<T> currentSplitFilterContent = new List<T>(blockSize);
            foreach (var item in listToSplit)
            {
                if (currentSplitFilterContent.Count < lotSize)
                {
                    currentSplitFilterContent.Add(item);
                }
                else
                {
                    listOfSplittedList.Add(currentSplitFilterContent);
                    currentSplitFilterContent = new List<T>(blockSize);
                    currentSplitFilterContent.Add(item);
                }
            }
            if (currentSplitFilterContent.Count > 0)
            {
                listOfSplittedList.Add(currentSplitFilterContent);
            }
            return listOfSplittedList;
        }
        private enum BoundType { Lower, Upper }
        private static int Dichotomy<Key>(IList<Key> keys, Key key, int min, int max, BoundType boundType, IComparer<Key> comparer)
        {
            if (max - min <= 1)
                return boundType == BoundType.Lower ? min : max;
            int mid = (min + max) / 2;
            int compare = comparer.Compare(key, keys[mid]);
            if (compare == 0)
                return mid;
            if (compare > 0)
                return Dichotomy(keys, key, mid, max, boundType, comparer);
            return Dichotomy(keys, key, min, mid, boundType, comparer);
        }
        private static bool Bound<Key, Value>(this SortedList<Key, Value> list, Key key, BoundType boundType, out KeyValuePair<Key, Value> bound)
        {
            if (list.Count == 0)
            {
                bound = default(KeyValuePair<Key, Value>);
                return false;
            }
            IList<Key> keys = list.Keys;
            int compareFirst = list.Comparer.Compare(keys[0], key);
            if (compareFirst >= 0)
            {
                bound = new KeyValuePair<Key, Value>(keys[0], list.Values[0]);
                return boundType == BoundType.Upper || compareFirst == 0;
            }
            int compareLast = list.Comparer.Compare(keys[keys.Count - 1], key);
            if (compareLast <= 0)
            {
                bound = new KeyValuePair<Key, Value>(keys[keys.Count - 1], list.Values[keys.Count - 1]);
                return boundType == BoundType.Lower || compareLast == 0;
            }
            int boundIndex = Dichotomy(keys, key, 0, keys.Count - 1, boundType, list.Comparer);
            bound = new KeyValuePair<Key, Value>(keys[boundIndex], list.Values[boundIndex]);
            return true;
        }
        public static bool LowerBound<Key, Value>(this SortedList<Key, Value> list, Key key, out KeyValuePair<Key, Value> lowerBound)
        {
            return Bound(list, key, BoundType.Lower, out lowerBound);
        }
        public static bool UpperBound<Key, Value>(this SortedList<Key, Value> list, Key key, out KeyValuePair<Key, Value> upperBound)
        {
            return Bound(list, key, BoundType.Upper, out upperBound);
        }
        public static bool IsNullOrEmpty<T>(this IEnumerable<T> @this)
        {
            return (@this == null) || (!@this.Any());
        }
        public static bool IsNotNullNorEmpty<T>(this IEnumerable<T> @this)
        {
            return !@this.IsNullOrEmpty();
        }
        public static void SafeEnumerator<T>(IEnumerator<T> en, Action<T> onSuccess, Action<Exception> onError, LogHelper logger)
        {
            bool hasNext = true;
            while (hasNext)
            {
                try
                {
                    if ((hasNext = en.MoveNext()) == true)
                    {
                        onSuccess(en.Current);
                    }
                }
                catch (Exception ex)
                {
                    try
                    {
                        onError(ex);
                    }
                    catch (Exception ex2)
                    {
                        if (logger != null)
                            logger.Error("SafeEnumerator: first I had :" + ex + Environment.NewLine + "...then I had, while trying to fire error: " + ex2);
                    }
                }
            }
        }
    }
}
============
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Text;
using System.ComponentModel;
using System.Xml.Serialization;
using Sgcib.TOne.ComponentModel;
namespace Sgcib.TOne.Util
{
    public static class EnumHelper
    {
        public static IEnumerable<T> Values<T> ()
        {
            return Enum.GetValues(typeof(T)).Cast<T>();
        }
        public static List<IEnumDefaulting> EnumDefaultings = new List<IEnumDefaulting>();
        #region EnumDefaultingHelper
        private static string GetDefaultValue(Type enumType, string unexpectedValue)
        {
            foreach (var e in EnumDefaultings)
            {
                if (e.GetEnumType() != null)
                    if (e.GetEnumType().Equals(enumType) && e.GetUnexpectedValue().Equals(unexpectedValue))
                        return e.GetDefaultValue();
            }
            return String.Empty;
        }
        #endregion
        public static T SafeParse<T>(string stringValue)
        {
            if (!Enum.IsDefined(typeof(T), stringValue))
            {
                stringValue = GetDefaultValue(typeof(T), stringValue);
                if (String.IsNullOrEmpty(stringValue))
                    throw new NotSupportedException(string.Format("The value {0} is not supported for type {1}", stringValue, typeof(T)));
            }
            return (T)Enum.Parse(typeof(T), stringValue);
        }
        public static bool TryParse<T>(string stringValue, out T parsedEnum)
        {
            if (!Enum.IsDefined(typeof(T), stringValue))
            {
                stringValue = GetDefaultValue(typeof(T), stringValue);
                if (String.IsNullOrEmpty(stringValue))
                {
                    parsedEnum = (T)Enum.Parse(typeof(T), Enum.GetNames(typeof(T))[0]);
                    return false;
                }
            }
            parsedEnum = (T)Enum.Parse(typeof(T), stringValue);
            return true;
        }
        public static bool TryParseNullable<T>(string stringValue, out T? parsedEnum) where T : struct
        {
            if (!Enum.IsDefined(typeof(T), stringValue))
            {
                stringValue = GetDefaultValue(typeof(T), stringValue);
                if (String.IsNullOrEmpty(stringValue))
                {
                    parsedEnum = null;
                    return false;
                }
            }
            parsedEnum = (T)Enum.Parse(typeof(T), stringValue);
            return true;
        }
        /// <summary>
        /// Parsing d'un Enum
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="stringValue">string  parser</param>
        /// <param name="valueIfNotValid">valeur  donner si Enum non dfini</param>
        /// <returns></returns>
        public static T SafeParse<T>(string stringValue, T valueIfNotValid)
        {
            return SafeParse(stringValue, valueIfNotValid, false);
        }
        /// <summary>
        /// Parsing d'un Enum
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="stringValue">string  parser</param>
        /// <param name="valueIfNotValid">valeur  donner si Enum non dfini</param>
        /// <param name="isPrefixedByTypeName"></param>
        /// <returns></returns>
        public static T SafeParse<T>(string stringValue, T valueIfNotValid, bool isPrefixedByTypeName)
        {
            string valueToParse = stringValue;
            if (isPrefixedByTypeName)
            {
                valueToParse = stringValue.Replace(typeof(T).Name + ".", string.Empty);
            }
            if (String.IsNullOrEmpty(valueToParse) || !Enum.IsDefined(typeof(T), valueToParse))
            {
                return valueIfNotValid;
            }
            return (T)Enum.Parse(typeof(T), valueToParse);
        }
        /// <summary>
        /// Parsing of an enum from the underlying value
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="stringValue">value to parse</param>
        /// <param name="valueIfNotValid">enum value if not defined</param>
        /// <returns></returns>
        public static T SafeParseValue<T>(string stringValue, T valueIfNotValid)
        {
            char chrValue;
            T obj = valueIfNotValid;
            if (!string.IsNullOrEmpty(stringValue))
            {
                if (char.TryParse(stringValue, out chrValue))
                    obj = (T)Enum.ToObject(typeof(T), chrValue);
            }
            if (!Enum.IsDefined(typeof(T), obj))
                obj = valueIfNotValid;
            return obj;
        }
// ReSharper disable InconsistentNaming
        public static T DBParse<T>(string stringValue, T nullValue)
// ReSharper restore InconsistentNaming
        {
            if (String.IsNullOrEmpty(stringValue))
                return nullValue;
            return (T)Enum.Parse(typeof(T), stringValue);
        }
        /// <summary>
        /// Return the string value defined by the <see cref="StringValueAttribute"/> attribute.
        /// </summary>
        /// <param name="enumValue">The enum value</param>
        /// <returns>The string value defined for the enum value, null if no StringValueAttribute is found for the given enum value</returns>
        public static string GetStringValue(Enum enumValue)
        {
            return GetStringValueInternal(enumValue);
        }
        internal static string GetStringValueInternal(object enumValue)
        {
            Type enumType = enumValue.GetType();
            FieldInfo fi = enumType.GetField(enumValue.ToString());
            var attrs = fi.GetCustomAttributes(typeof(StringValueAttribute), false) as StringValueAttribute[];
            if (attrs != null && attrs.Length > 0)
            {
                return attrs[0].Value;
            }
            return null;
        }
        /// <summary>
        /// Return the description defined by the <see cref="DescriptionAttribute"/> attribute.
        /// </summary>
        /// <param name="enumValue">The enum value</param>
        /// <returns>The description defined for the enum value, null if no DescriptionAttribute is found for the given enum value</returns>
        public static string GetDescription(Enum enumValue)
        {
            return GetDescription(enumValue, false);
        }
        /// <summary>
        /// Return the description defined by the <see cref="DescriptionAttribute"/> attribute.
        /// </summary>
        /// <param name="enumValue">The enum value</param>
        /// <param name="returnNameIfNoAttributeFound"></param>
        /// <returns>The description defined for the enum value, the enum value name if no DescriptionAttribute is found for the given enum value</returns>
        public static string GetDescription(Enum enumValue, bool returnNameIfNoAttributeFound)
        {
            return GetDescription(enumValue.GetType(), enumValue.ToString(), returnNameIfNoAttributeFound);
        }
        /// <summary>
        /// Return the description defined by the <see cref="DescriptionAttribute"/> attribute.
        /// </summary>
        /// <param name="enumType">The enum type</param>
        /// <param name="enumValue">The enum string value</param>
        /// <param name="returnNameIfNoAttributeFound"></param>
        /// <returns>The description defined for the enum value, the enum value name if no DescriptionAttribute is found for the given enum value</returns>
        public static string GetDescription(Type enumType, string enumValue, bool returnNameIfNoAttributeFound)
        {
            FieldInfo fi = enumType.GetField(enumValue);
            if (fi != null)
            {
                DescriptionAttribute[] attrs = fi.GetCustomAttributes(typeof(DescriptionAttribute), false) as DescriptionAttribute[];
                if (attrs != null && attrs.Length > 0)
                {
                    return attrs[0].Description;
                }
                return returnNameIfNoAttributeFound ? fi.Name : null;
            }
            return null;
        }
        /// <summary>
        /// Parse the string value and return the associated enum value
        /// </summary>
        /// <param name="enumType">The enum type</param>
        /// <param name="stringValue">The string value to parse</param>
        /// <param name="ignoreCase">Ignore case for parsing</param>
        /// <returns>The found enum value, null otherwise</returns>
        public static object ParseStringValue(Type enumType, string stringValue, bool ignoreCase)
        {
            StringValueAttribute[] currentAttrs;
            if (!enumType.IsEnum)
            {
                throw new ArgumentException(String.Format("Given type must be an Enum. Type was {0}", enumType.FullName));
            }
            foreach (FieldInfo currentFieldInfo in enumType.GetFields())
            {
                currentAttrs = currentFieldInfo.GetCustomAttributes(typeof(StringValueAttribute), false) as StringValueAttribute[];
                if (currentAttrs != null && currentAttrs.Length > 0 && String.Compare(currentAttrs[0].Value, stringValue, ignoreCase) == 0)
                {
                    return Enum.Parse(enumType, currentFieldInfo.Name);
                }
            }
            // In case we don't find any corresponding, maybe stringValue is a too new value => use defaulting system
            stringValue = GetDefaultValue(enumType, stringValue);
            if (!String.IsNullOrEmpty(stringValue))
            {
                foreach (FieldInfo currentFieldInfo in enumType.GetFields())
                {
                    currentAttrs = currentFieldInfo.GetCustomAttributes(typeof(StringValueAttribute), false) as StringValueAttribute[];
                    if (currentAttrs != null && currentAttrs.Length > 0 && String.Compare(currentAttrs[0].Value, stringValue, ignoreCase) == 0)
                    {
                        return Enum.Parse(enumType, currentFieldInfo.Name);
                    }
                }
            }
            return null;
        }
        public static object ParseStringValue(Type enumType, string stringValue, bool ignoreCase, object defaultNullValue)
        {
            object result = ParseStringValue(enumType, stringValue, ignoreCase);
            if (result == null)
            {
                return defaultNullValue;
            }
            return result;
        }
        public static bool TryParseXmlEnumValue<T>(string xmlEnumValue, out T parsedEnum)
        {
            return EnumHelper<T>.TryParseXmlEnumValue(xmlEnumValue, out parsedEnum);
        }
        public static T ToEnum<T>(this string text)
            where T : struct
        {
            return EnumHelper<T>.Parse(text);
        }
        public static string ToString(object enumValue)
        {
            var helperType = typeof(EnumHelper<>).MakeGenericType(enumValue.GetType());
            return (string)helperType.InvokeMember("ToString", BindingFlags.InvokeMethod | BindingFlags.Static | BindingFlags.Public, null, null, new[] { enumValue });
        }
        public static ArgumentOutOfRangeException OutOfRange<T>(this T value, string paramName)
            where T : struct
        {
            return new ArgumentOutOfRangeException(paramName, value, "unknown or out of range value " + value + " for " + typeof(T));
        }
    }
    public static class EnumHelper<T>
    {
        public static readonly Dictionary<T, FieldInfo> MemberCache;
        private static readonly Dictionary<T, string> ToStringCache;
        private static readonly Dictionary<string, T> FromStringCache;
        private static readonly List<KeyValuePair<int, string>> FlagsCacheInt32;
        private static readonly List<KeyValuePair<byte, string>> FlagsCacheByte;
        private static readonly bool IsInt32Type;
        private static readonly bool IsByteType;
        #region .ctor
        static EnumHelper()
        {
            if (!typeof(T).IsEnum)
                throw new NotSupportedException("EnumHelper is for Enums only, obviously");
            if (Enum.GetUnderlyingType(typeof(T)) == typeof(Int32))
                IsInt32Type = true;
            if (Enum.GetUnderlyingType(typeof(T)) == typeof(Byte))
                IsByteType = true;
            if (!(IsInt32Type || IsByteType))
                throw new NotSupportedException("EnumHelper just support Int32 or Byte underlying type.");
            MemberCache = Enum
                .GetValues(typeof(T))
                .Cast<T>()
                .ToDictionary(
                    value => value,
                    value => typeof(T).GetField(value.ToString())
                );
            if (IsInt32Type)
            {
                FlagsCacheInt32 = MemberCache
                .Select(pair => new KeyValuePair<int, string>((int)(object)pair.Key, pair.Value.Name))
                .OrderByDescending(pair => pair.Key)
                .ToList();
            }
            else
            {
                FlagsCacheByte = MemberCache
                .Select(pair => new KeyValuePair<byte, string>((byte)(object)pair.Key, pair.Value.Name))
                .OrderByDescending(pair => pair.Key)
                .ToList();
            }
            ToStringCache = MemberCache
                .ToDictionary(pair => pair.Key, pair => typeof(T).Name + '.' + pair.Value.Name);
            FromStringCache = MemberCache
                .ToDictionary(pair => pair.Value.Name, pair => pair.Key);
        }
        #endregion
        #region EnumStringValues
        private static IDictionary<T, String> _stringValues;
        private readonly static object StringValuesCacheSyncRoot = new object();
        public static IDictionary<T, String> StringValues
        {
            get
            {
                if (_stringValues == null)
                {
                    lock (StringValuesCacheSyncRoot)
                    {
                        if (_stringValues == null)
                        {
                            _stringValues = Enum.GetValues(typeof (T))
                                                .Cast<T>()
                                                .ToDictionary(k => k, k => EnumHelper.GetStringValueInternal(k));
                        }
                    }
                }
                return _stringValues;
            }
        }
        #endregion EnumStringValues
        #region XmlEnumAttribute
        private static Dictionary<string, List<T>> _fromXmlEnumNameCache;
        private readonly static object FromXmlEnumNameCacheSyncRoot = new object();
        private static Dictionary<string, List<T>> FromXmlEnumNameCache
        {
            get
            {
                if (_fromXmlEnumNameCache == null)
                {
                    lock (FromXmlEnumNameCacheSyncRoot)
                    {
                        if (_fromXmlEnumNameCache == null)
                        {
                            _fromXmlEnumNameCache = CreateFromXmlEnumNameCache();
                        }
                    }
                }
                return _fromXmlEnumNameCache;
            }
        }
        private static Dictionary<string, List<T>> CreateFromXmlEnumNameCache()
        {
            return MemberCache
                .Select(pair =>
                {
                    XmlEnumAttribute xmlEnumAttribute = pair.Value.GetCustomAttribute<XmlEnumAttribute>();
                    return new
                    {
                        EnumValue = pair.Key,
                        XmlEnumName = xmlEnumAttribute == null || xmlEnumAttribute.Name == null
                            ? pair.Key.ToString() : xmlEnumAttribute.Name,
                    };
                })
                .GroupBy(pair => pair.XmlEnumName)
                .ToDictionary(pair => pair.Key, pair => pair.Select(p => p.EnumValue).ToList());
        }
        public static bool TryParseXmlEnumValue(string xmlEnumValue, out T parsedEnum)
        {
            List<T> possibleValues;
            parsedEnum = default(T);
            if (FromXmlEnumNameCache.TryGetValue(xmlEnumValue, out possibleValues)
                && possibleValues != null
                && possibleValues.Count == 1)
            {
                parsedEnum = possibleValues.First();
                return true;
            }
            return false;
        }
        #endregion
        public static IEnumerable<T> Values
        {
            get { return MemberCache.Keys; }
        }
        public static string GetName(T value)
        {
            return MemberCache[value].Name;
        }
        public static IList GetStringValues()
        {
            return StringValues.ToList();
        }
        public static string ToString(T value)
        {
            return ToStringCache.GetOrAdd(value, ResolveToString);
        }
        private static string ResolveToString(T value)
        {
            var sb = new StringBuilder();
            var prefix = typeof(T).Name + '.';
            var i = (int)(object)value;
            if (IsInt32Type)
            {
                foreach (var name in FlagsCacheInt32)
                {
                    if ((i & name.Key) != name.Key)
                        continue;
                    if (sb.Length != 0)
                        sb.Append('|');
                    sb.Append(prefix);
                    sb.Append(name.Value);
                    i -= name.Key;
                    if (i == 0)
                        break;
                }
            }
            else
            {
                foreach (var name in FlagsCacheByte)
                {
                    if ((i & name.Key) != name.Key)
                        continue;
                    if (sb.Length != 0)
                        sb.Append('|');
                    sb.Append(prefix);
                    sb.Append(name.Value);
                    i -= name.Key;
                    if (i == 0)
                        break;
                }
            }
            return sb.ToString();
        }
        public static T ParseOrDefault(string str, T valueIfNotValid)
        {
            T value;
            return (!string.IsNullOrEmpty(str) && FromStringCache.TryGetValue(str, out value))
                       ? value
                       : valueIfNotValid;
        }
        public static T ParseOrDefault(string str)
        {
            return ParseOrDefault(str, default(T));
        }
        public static T Parse(string value)
        {
            return EnumHelper.SafeParse<T>(value);
        }
        /// <summary>
        /// Tip: Use it as ParseStringValue&lt;MyEnum?&gt;(string).
        /// Otherwise, if given string cannot be parsed, it will return your enum default value.
        /// </summary>
        public static T ParseStringValue(string value)
        {
            var typ = typeof(T);
            if (typ.IsNullable())
                typ = typ.GetGenericArguments()[0];
            return (T)(EnumHelper.ParseStringValue(typ, value, false) ?? default(T));
        }
        /// <summary>
        /// for Enum { First, [Att]Second, Third } return { Second }
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <typeparam name="TAttribute"></typeparam>
        /// <returns></returns>
        public static IList<T> GetMembersWithAttribute<TAttribute>()
            where TAttribute : Attribute
        {
            return MemberCache
                    .Where(k => k.Value
                                    .GetCustomAttributes(typeof(TAttribute), false)
                                    .FirstOrDefault() as TAttribute != null)
                    .Select(v => v.Key)
                    .ToList();
        }
         /// <summary>
        /// Return the implementation defined by the <see cref="ImplementedByAttribute"/> attribute.
        /// </summary>
        /// <param name="enumeration">The enum</param>
        /// <returns>The description defined for the enum value, the enum value name if no DescriptionAttribute is found for the given enum value</returns>
        public static IEnumerable<TImpl> GetImplementation<TImpl>(Enum enumeration)
         {
             var list = new List<TImpl>();
             var enumType = enumeration.GetType();
             // ReSharper disable LoopCanBeConvertedToQuery
             foreach (var enumValue in Enum.GetValues(enumType))
                 // ReSharper restore LoopCanBeConvertedToQuery
             {
                 var fi = enumType.GetField(enumValue.ToString());
                 if (fi == null) continue;
                 var attrs =
                     fi.GetCustomAttributes(typeof (ImplementedByAttribute), false) as ImplementedByAttribute[];
                 if (attrs == null || attrs.Length <= 0) continue;
                 var implementBy = attrs[0];
                 list.Add(InstanceHelper.NewInstance(implementBy.ResolvedType, new object[] { }) is TImpl ? (TImpl)InstanceHelper.NewInstance(implementBy.ResolvedType, new object[] { }) : default(TImpl));
             }
             return list;
         }
    }
    public static class FlagsHelper
    {
        public static IEnumerable<T> GetFlags<T>(this T input)
            where T : struct
        {
            Enum flags = input as Enum;
            if (flags != null)
            {
                foreach (T value in Enum.GetValues(typeof(T)).Cast<T>())
                {
                    if (flags.HasFlag(value))
                        yield return value;
                }
            }
        }
        //checks if the value contains the provided type
        //beware it is not the fastest way of testing it
        public static bool HasFlag<T>(this Enum type, T value)
        {
            try
            {
                return (((int)(object)type & (int)(object)value) == (int)(object)value);
            }
            catch
            {
                return false;
            }
        }
        //checks if the value is only the provided type
        public static bool IsFlag<T>(this Enum type, T value)
        {
            try
            {
                return (int)(object)type == (int)(object)value;
            }
            catch
            {
                return false;
            }
        }
        //appends a value
        public static T AddFlag<T>(this Enum type, T value)
        {
            try
            {
                return (T)(object)(((int)(object)type | (int)(object)value));
            }
            catch (Exception ex)
            {
                throw new ArgumentException(
                    string.Format(
                        "Could not append value from enumerated type '{0}'.",
                        typeof(T).Name
                        ), ex);
            }
        }
        //completely removes the value
        public static T RemoveFlag<T>(this Enum type, T value)
        {
            try
            {
                return (T)(object)(((int)(object)type & ~(int)(object)value));
            }
            catch (Exception ex)
            {
                throw new ArgumentException(
                    string.Format(
                        "Could not remove value from enumerated type '{0}'.",
                        typeof(T).Name
                        ), ex);
            }
        }
    }
}
=====
using System.Collections.Generic;
using System.Collections.Specialized;
// ReSharper disable CheckNamespace
namespace System.Collections.ObjectModel
// ReSharper restore CheckNamespace
{
    /// <summary>
    /// Observable dictionary.
    /// </summary>
    /// <typeparam name="TKey">Key type.</typeparam>
    /// <typeparam name="TValue">Value type.</typeparam>
    [Serializable]
    public class XObservableDictionary<TKey, TValue>
        : IDictionary<TKey, TValue>,
          INotifyCollectionChanged,
          IEquatable<Object>
    {
        #region Properties
        /// <summary>
        /// Dictionary.
        /// </summary>
        protected IDictionary<TKey, TValue> InternalDictionary { get; private set; }
        #endregion Properties
        #region Constructors
        /// <summary>
        /// Initializes a new instance of the <see cref="XObservableDictionary{TKey,TValue}"/> class.
        /// </summary>
        public XObservableDictionary()
        {
            InternalDictionary = new Dictionary<TKey, TValue>();
        }
        /// <summary>
        /// Initializes a new instance of the <see cref="XObservableDictionary{TKey,TValue}"/> class
        /// with the specified dictionary.
        /// </summary>
        /// <param name="dictionary">Dictionary.</param>
        public XObservableDictionary(IDictionary<TKey, TValue> dictionary)
        {
            InternalDictionary = new Dictionary<TKey, TValue>(dictionary);
        }
        /// <summary>
        /// Initializes a new instance of the <see cref="XObservableDictionary{TKey,TValue}"/> class
        /// with the specified key comparer.
        /// </summary>
        /// <param name="comparer">Key comparer.</param>
        public XObservableDictionary(IEqualityComparer<TKey> comparer)
        {
            InternalDictionary = new Dictionary<TKey, TValue>(comparer);
        }
        /// <summary>
        /// Initializes a new instance of the <see cref="XObservableDictionary{TKey,TValue}"/> class
        /// with the specified capacity.
        /// </summary>
        /// <param name="capacity">Capacity.</param>
        public XObservableDictionary(Int32 capacity)
        {
            InternalDictionary = new Dictionary<TKey, TValue>(capacity);
        }
        /// <summary>
        /// Initializes a new instance of the <see cref="XObservableDictionary{TKey,TValue}"/> class
        /// with the specified dictionary and key comparer.
        /// </summary>
        /// <param name="dictionary">Dictionary.</param>
        /// <param name="comparer">Key comparer.</param>
        public XObservableDictionary(IDictionary<TKey, TValue> dictionary, IEqualityComparer<TKey> comparer)
        {
            InternalDictionary = new Dictionary<TKey, TValue>(dictionary, comparer);
        }
        /// <summary>
        /// Initialise une nouvelle instance de la classe qui possde la capacit initale spcifie et qui utilise le comparateur d'galit spcifi pour le type de cl.
        /// </summary>
        /// <param name="capacity">Nombre initial d'lments que le dictionnaire peut contenir.</param>
        /// <param name="comparer">Comparateur de cls.</param>
        public XObservableDictionary(Int32 capacity, IEqualityComparer<TKey> comparer)
        {
            InternalDictionary = new Dictionary<TKey, TValue>(capacity, comparer);
        }
        #endregion
        #region Implementation of IEnumerable
        /// <summary>
        /// Returns an enumerator that iterates through the collection.
        /// </summary>
        /// <returns>
        /// A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate through the collection.
        /// </returns>
        /// <filterpriority>1</filterpriority>
        public IEnumerator<KeyValuePair<TKey, TValue>> GetEnumerator()
        {
            return InternalDictionary.GetEnumerator();
        }
        /// <summary>
        /// Returns an enumerator that iterates through a collection.
        /// </summary>
        /// <returns>
        /// An <see cref="T:System.Collections.IEnumerator"/> object that can be used to iterate through the collection.
        /// </returns>
        /// <filterpriority>2</filterpriority>
        IEnumerator IEnumerable.GetEnumerator()
        {
            return InternalDictionary.GetEnumerator();
        }
        #endregion
        #region Implementation of ICollection<KeyValuePair<TKey,TValue>>
        /// <summary>
        /// Adds an item to the <see cref="T:System.Collections.Generic.ICollection`1"/>.
        /// </summary>
        /// <param name="item">The object to add to the <see cref="T:System.Collections.Generic.ICollection`1"/>.
        ///                 </param><exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.ICollection`1"/> is read-only.
        ///                 </exception>
        public void Add(KeyValuePair<TKey, TValue> item)
        {
            Insert(item.Key, item.Value, false);
        }
        /// <summary>
        /// Removes all items from the <see cref="T:System.Collections.Generic.ICollection`1"/>.
        /// </summary>
        /// <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.ICollection`1"/> is read-only.
        ///                 </exception>
        public void Clear()
        {
            if (InternalDictionary.Count <= 0) return;
            InternalDictionary.Clear();
            OnCollectionItemsCleared();
        }
        /// <summary>
        /// Determines whether the <see cref="T:System.Collections.Generic.ICollection`1"/> contains a specific value.
        /// </summary>
        /// <returns>
        /// true if <paramref name="item"/> is found in the <see cref="T:System.Collections.Generic.ICollection`1"/>; otherwise, false.
        /// </returns>
        /// <param name="item">The object to locate in the <see cref="T:System.Collections.Generic.ICollection`1"/>.
        ///                 </param>
        public Boolean Contains(KeyValuePair<TKey, TValue> item)
        {
            return InternalDictionary.Contains(item);
        }
        /// <summary>
        /// Copies the elements of the <see cref="T:System.Collections.Generic.ICollection`1"/> to an <see cref="T:System.Array"/>, starting at a particular <see cref="T:System.Array"/> index.
        /// </summary>
        /// <param name="array">The one-dimensional <see cref="T:System.Array"/> that is the destination of the elements copied from <see cref="T:System.Collections.Generic.ICollection`1"/>. The <see cref="T:System.Array"/> must have zero-based indexing.
        ///                 </param><param name="arrayIndex">The zero-based index in <paramref name="array"/> at which copying begins.
        ///                 </param><exception cref="T:System.ArgumentNullException"><paramref name="array"/> is null.
        ///                 </exception><exception cref="T:System.ArgumentOutOfRangeException"><paramref name="arrayIndex"/> is less than 0.
        ///                 </exception><exception cref="T:System.ArgumentException"><paramref name="array"/> is multidimensional.
        ///                     -or-
        ///                 <paramref name="arrayIndex"/> is equal to or greater than the length of <paramref name="array"/>.
        ///                     -or-
        ///                     The number of elements in the source <see cref="T:System.Collections.Generic.ICollection`1"/> is greater than the available space from <paramref name="arrayIndex"/> to the end of the destination <paramref name="array"/>.
        ///                     -or-
        ///                     Type T cannot be cast automatically to the type of the destination <paramref name="array"/>.
        ///                 </exception>
        public void CopyTo(KeyValuePair<TKey, TValue>[] array, Int32 arrayIndex)
        {
            InternalDictionary.CopyTo(array, arrayIndex);
        }
        /// <summary>
        /// Removes the first occurrence of a specific object from the <see cref="T:System.Collections.Generic.ICollection`1"/>.
        /// </summary>
        /// <returns>
        /// true if <paramref name="item"/> was successfully removed from the <see cref="T:System.Collections.Generic.ICollection`1"/>; otherwise, false. This method also returns false if <paramref name="item"/> is not found in the original <see cref="T:System.Collections.Generic.ICollection`1"/>.
        /// </returns>
        /// <param name="item">The object to remove from the <see cref="T:System.Collections.Generic.ICollection`1"/>.
        ///                 </param><exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.ICollection`1"/> is read-only.
        ///                 </exception>
        public Boolean Remove(KeyValuePair<TKey, TValue> item)
        {
            TValue value;
            if (!InternalDictionary.TryGetValue(item.Key, out value)) return false;
            InternalDictionary.Remove(item.Key);
            OnCollectionItemAddedOrRemoved(NotifyCollectionChangedAction.Remove, new KeyValuePair<TKey, TValue>(item.Key, value));
            return true;
        }
        /// <summary>
        /// Gets the number of elements contained in the <see cref="T:System.Collections.Generic.ICollection`1"/>.
        /// </summary>
        /// <returns>
        /// The number of elements contained in the <see cref="T:System.Collections.Generic.ICollection`1"/>.
        /// </returns>
        public Int32 Count
        {
            get
            {
                return InternalDictionary.Count;
            }
        }
        /// <summary>
        /// Gets a value indicating whether the <see cref="T:System.Collections.Generic.ICollection`1"/> is read-only.
        /// </summary>
        /// <returns>
        /// true if the <see cref="T:System.Collections.Generic.ICollection`1"/> is read-only; otherwise, false.
        /// </returns>
        public Boolean IsReadOnly
        {
            get
            {
                return InternalDictionary.IsReadOnly;
            }
        }
        #endregion
        #region Implementation of IDictionary<TKey,TValue>
        /// <summary>
        /// Determines whether the <see cref="T:System.Collections.Generic.IDictionary`2"/> contains an element with the specified key.
        /// </summary>
        /// <returns>
        /// true if the <see cref="T:System.Collections.Generic.IDictionary`2"/> contains an element with the key; otherwise, false.
        /// </returns>
        /// <param name="key">The key to locate in the <see cref="T:System.Collections.Generic.IDictionary`2"/>.
        ///                 </param><exception cref="T:System.ArgumentNullException"><paramref name="key"/> is null.
        ///                 </exception>
        public Boolean ContainsKey(TKey key)
        {
            return InternalDictionary.ContainsKey(key);
        }
        /// <summary>
        /// Adds an element with the provided key and value to the <see cref="T:System.Collections.Generic.IDictionary`2"/>.
        /// </summary>
        /// <param name="key">The object to use as the key of the element to add.
        ///                 </param><param name="value">The object to use as the value of the element to add.
        ///                 </param><exception cref="T:System.ArgumentNullException"><paramref name="key"/> is null.
        ///                 </exception><exception cref="T:System.ArgumentException">An element with the same key already exists in the <see cref="T:System.Collections.Generic.IDictionary`2"/>.
        ///                 </exception><exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.IDictionary`2"/> is read-only.
        ///                 </exception>
        public void Add(TKey key, TValue value)
        {
            Insert(key, value, false);
        }
        /// <summary>
        /// Removes the element with the specified key from the <see cref="T:System.Collections.Generic.IDictionary`2"/>.
        /// </summary>
        /// <returns>
        /// true if the element is successfully removed; otherwise, false.  This method also returns false if <paramref name="key"/> was not found in the original <see cref="T:System.Collections.Generic.IDictionary`2"/>.
        /// </returns>
        /// <param name="key">The key of the element to remove.
        ///                 </param><exception cref="T:System.ArgumentNullException"><paramref name="key"/> is null.
        ///                 </exception><exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.IDictionary`2"/> is read-only.
        ///                 </exception>
        public Boolean Remove(TKey key)
        {
            TValue value;
            if (!InternalDictionary.TryGetValue(key, out value)) return false;
            InternalDictionary.Remove(key);
            OnCollectionItemAddedOrRemoved(NotifyCollectionChangedAction.Remove, new KeyValuePair<TKey, TValue>(key, value));
            return true;
        }
        /// <summary>
        /// Gets the value associated with the specified key.
        /// </summary>
        /// <returns>
        /// true if the object that implements <see cref="T:System.Collections.Generic.IDictionary`2"/> contains an element with the specified key; otherwise, false.
        /// </returns>
        /// <param name="key">The key whose value to get.
        ///                 </param><param name="value">When this method returns, the value associated with the specified key, if the key is found; otherwise, the default value for the type of the <paramref name="value"/> parameter. This parameter is passed uninitialized.
        ///                 </param><exception cref="T:System.ArgumentNullException"><paramref name="key"/> is null.
        ///                 </exception>
        public Boolean TryGetValue(TKey key, out TValue value)
        {
            return InternalDictionary.TryGetValue(key, out value);
        }
        /// <summary>
        /// Gets or sets the element with the specified key.
        /// </summary>
        /// <returns>
        /// The element with the specified key.
        /// </returns>
        /// <param name="key">The key of the element to get or set.
        ///                 </param><exception cref="T:System.ArgumentNullException"><paramref name="key"/> is null.
        ///                 </exception><exception cref="T:System.Collections.Generic.KeyNotFoundException">The property is retrieved and <paramref name="key"/> is not found.
        ///                 </exception><exception cref="T:System.NotSupportedException">The property is set and the <see cref="T:System.Collections.Generic.IDictionary`2"/> is read-only.
        ///                 </exception>
        public TValue this[TKey key]
        {
            get
            {
                return InternalDictionary[key];
            }
            set
            {
                Insert(key, value, true);
            }
        }
        /// <summary>
        /// Gets an <see cref="T:System.Collections.Generic.ICollection`1"/> containing the keys of the <see cref="T:System.Collections.Generic.IDictionary`2"/>.
        /// </summary>
        /// <returns>
        /// An <see cref="T:System.Collections.Generic.ICollection`1"/> containing the keys of the object that implements <see cref="T:System.Collections.Generic.IDictionary`2"/>.
        /// </returns>
        public ICollection<TKey> Keys
        {
            get
            {
                return InternalDictionary.Keys;
            }
        }
        /// <summary>
        /// Gets an <see cref="T:System.Collections.Generic.ICollection`1"/> containing the values in the <see cref="T:System.Collections.Generic.IDictionary`2"/>.
        /// </summary>
        /// <returns>
        /// An <see cref="T:System.Collections.Generic.ICollection`1"/> containing the values in the object that implements <see cref="T:System.Collections.Generic.IDictionary`2"/>.
        /// </returns>
        public ICollection<TValue> Values
        {
            get
            {
                return InternalDictionary.Values;
            }
        }
        #endregion
        #region Implementation of INotifyCollectionChanged
        /// <summary>
        /// Triggered when the dictionary content changes.
        /// </summary>
        public event NotifyCollectionChangedEventHandler CollectionChanged;
        /// <summary>
        /// Triggers <see cref="CollectionChanged"/> with the specified action and item.
        /// </summary>
        /// <param name="action">Action.</param>
        /// <param name="changedItem">Changed item.</param>
        protected virtual void OnCollectionItemAddedOrRemoved(NotifyCollectionChangedAction action, KeyValuePair<TKey, TValue> changedItem)
        {
            if (CollectionChanged != null)
            {
                CollectionChanged(this, new NotifyCollectionChangedEventArgs(action, changedItem));
            }
        }
        /// <summary>
        /// Triggers <see cref="CollectionChanged"/> with <see cref="NotifyCollectionChangedAction.Replace"/>
        /// and the specified new items and old items.
        /// </summary>
        /// <param name="newItem">New items.</param>
        /// <param name="oldItem">Old items.</param>
        protected virtual void OnCollectionChanged(KeyValuePair<TKey, TValue> newItem, KeyValuePair<TKey, TValue> oldItem)
        {
            if (CollectionChanged != null)
            {
                CollectionChanged(this, new NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction.Replace, newItem, oldItem));
            }
        }
        /// <summary>
        /// Triggers <see cref="CollectionChanged"/> with <see cref="NotifyCollectionChangedAction.Reset"/>.
        /// </summary>
        protected virtual void OnCollectionItemsCleared()
        {
            if (CollectionChanged != null)
            {
                CollectionChanged(this, new NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction.Reset));
            }
        }
        #endregion
        #region Methods
        /// <summary>
        /// Inserts or updates an element with the specified key and value ; with or without overwriting its data.
        /// </summary>
        /// <param name="key">Key.</param>
        /// <param name="value">Value.</param>
        /// <param name="overwrite"><see langword="true"/> if the item can be overwritten; otherwise, <see langword="false"/>.</param>
        private void Insert(TKey key, TValue value, Boolean overwrite)
        {
            // NOTE: Although key is not always a class type (and therefore null-able), it can be.
            // ReSharper disable CompareNonConstrainedGenericWithNull
            if (key == null) throw new ArgumentNullException("key");
            // ReSharper restore CompareNonConstrainedGenericWithNull
            TValue item;
            if (InternalDictionary.TryGetValue(key, out item))
            {
                if (!overwrite) throw new ArgumentException("An item with the same key has already been added.");
                if (!Equals(item, value))
                {
                    InternalDictionary[key] = value;
                    OnCollectionChanged(new KeyValuePair<TKey, TValue>(key, value), new KeyValuePair<TKey, TValue>(key, item));
                }
            }
            else
            {
                InternalDictionary[key] = value;
                OnCollectionItemAddedOrRemoved(NotifyCollectionChangedAction.Add, new KeyValuePair<TKey, TValue>(key, value));
            }
        }
        #endregion Methods
    }
}using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Linq;
using System.Runtime.Serialization.Formatters.Binary;
using System.Text;
using Sgcib.TOne.Util.IO;
namespace Sgcib.TOne.Util
{
    /// <summary>
    /// Various helper methods to manipulate collections.
    /// </summary>
    public static class CollectionHelper
    {
        public static string Flatten<T>(this IEnumerable<T> sequence, string separator, Func<int, T, string> toString)
        {
            bool first = true;
            int i = 0;
            var result = new StringBuilder();
            foreach (var item in sequence)
            {
                if (!first)
                    result.Append(separator);
                if (first)
                {
                    first = false;
                }
                result.Append(toString(i, item));
                i++;
            }
            return result.ToString();
        }
        public static string Flatten<T>(this IEnumerable<T> sequence, string separator, Func<T, string> toString)
        {
            return Flatten(sequence, separator, (i, item) => toString(item));
        }
        public static void Each<T>(this IEnumerable<T> sequence, Action<T> action)
        {
            foreach (var item in sequence)
                action(item);
        }
        public static void Each<T>(this IEnumerable<T> sequence, Action<int, T> action)
        {
            int index = 0;
            foreach (var item in sequence)
            {
                action(index, item);
                index++;
            }
        }
        public static int Walk(this IEnumerable source)
        {
            var count = 0;
            var e = source.GetEnumerator();
            var d = e as IDisposable;
            if (d != null)
                using (d)
                    while (e.MoveNext())
                        count++;
            else
                while (e.MoveNext())
                    count++;
            return count;
        }
        public static IEnumerable<T> CloneAll<T>(this IEnumerable<T> source)
            where T : ICloneable<T>
        {
            return source.Select(item => item.Clone());
        }
        public static T AddTo<T>(this T item, ref Queue<T> queue)
        {
            if (queue == null)
                queue = new Queue<T>();
            queue.Enqueue(item);
            return item;
        }
        public static T AddTo<T>(this T item, ref List<T> list)
        {
            if (list == null)
                list = new List<T>();
            list.Add(item);
            return item;
        }
        public static T RemoveFrom<T>(this T item, ref List<T> list)
        {
            if (list.Remove(item))
                if (list.Count == 0)
                    list = null;
            return item;
        }
        public static T AddTo<T>(this T item, ref Stack<T> stack)
        {
            if (stack == null)
                stack = new Stack<T>();
            stack.Push(item);
            return item;
        }
        /// <summary>
        /// Return chunks from an enumeration , goupsize can be 0, or negative , or Int32.Max : this will return only one chunk
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="enumerable"></param>
        /// <param name="groupSize"></param>
        /// <returns></returns>
        public static IEnumerable<List<T>> SafeChunk<T>(this IEnumerable<T> enumerable, int groupSize)
        {
            // The list to return.
            List<T> list = new List<T>();
            // Cycle through all of the items.
            foreach (T item in enumerable)
            {
                // Add the item.
                list.Add(item);
                // If the list has the number of elements, return that.
                if (list.Count == groupSize)
                {
                    // Return the list.
                    yield return list;
                    // Set the list to a new list.
                    list = new List<T>();
                }
            }
            // Return the remainder if there is any,
            if (list.Count != 0)
            {
                // Return the list.
                yield return list;
            }
        }
        public static IEnumerable<List<T>> Chunk<T>(this IEnumerable<T> enumerable, int groupSize)
        {
            Check.That(groupSize > 0, () => "Invalid group size " + groupSize);
            // The list to return.
            List<T> list = new List<T>(groupSize);
            // Cycle through all of the items.
            foreach (T item in enumerable)
            {
                // Add the item.
                list.Add(item);
                // If the list has the number of elements, return that.
                if (list.Count == groupSize)
                {
                    // Return the list.
                    yield return list;
                    // Set the list to a new list.
                    list = new List<T>(groupSize);
                }
            }
            // Return the remainder if there is any,
            if (list.Count != 0)
            {
                // Return the list.
                yield return list;
            }
        }
        public static TOut[] CastArray<TIn, TOut>(this TIn[] input)
            where TOut : TIn
        {
            var output = new TOut[input.Length];
            for (var i = 0; i < input.Length; i++)
                output[i] = (TOut)input[i];
            return output;
        }
        public static TOut[] ConvertAll<TIn, TOut>(this TIn[] input, Func<TIn, TOut> convert)
        {
            var output = new TOut[input.Length];
            for (var i = 0; i < input.Length; i++)
                output[i] = convert(input[i]);
            return output;
        }
        public static IEnumerable<T> Concat<T>(this IEnumerable<T> source, params T[] second)
        {
            return Enumerable.Concat(source, second);
        }
        public static IEnumerable<T> Except<T>(this IEnumerable<T> source, params T[] second)
        {
            return Enumerable.Except(source, second);
        }
        public static string[] ToArray(this StringCollection coll)
        {
            var array = new string[coll.Count];
            coll.CopyTo(array, 0);
            return array;
        }
        public static HashSet<T> ToHashSet<T>(this IEnumerable<T> source)
        {
            return new HashSet<T>(source.Distinct());
        }
        public static HashSet<T> AddRange<T>(this HashSet<T> hashSet, IEnumerable<T> range)
        {
            foreach (T toAdd in range)
                hashSet.Add(toAdd);
            return hashSet;
        }
        public static IEnumerable<string> StringJoinSplit(this IEnumerable<string> source, string separator, int maxlength)
        {
            Check.ArgumentNotNull(source, "source");
            Check.ArgumentNotNull(separator, "separator");
            Check.That(maxlength > 0, "maxlength");
            var separatorLength = separator.Length;
            var remainingItems = source.StringJoin(separator);
            var remainingItemsLength = remainingItems.Length;
            while (remainingItemsLength >= maxlength)
            {
                var splitPos = remainingItems.LastIndexOf(separator, maxlength, maxlength, StringComparison.Ordinal);
                if (splitPos == -1)
                    break;
                if (splitPos == 0)
                {
                    remainingItems = remainingItems.Substring(separatorLength);
                    continue;
                }
                var nextItemsToSend = remainingItems.Substring(0, splitPos);
                yield return nextItemsToSend;
                var remainingItemsPos = splitPos + separatorLength;
                remainingItems = (remainingItemsLength > remainingItemsPos) ? remainingItems.Substring(remainingItemsPos) : string.Empty;
                remainingItemsLength = remainingItems.Length;
            }
            if (!string.IsNullOrEmpty(remainingItems))
                yield return remainingItems;
        }
        public static List<List<T>> Split<T>(this IList<T> list, Func<T, bool> isSpliiter, bool removeSplitter = true)
        {
            var skip = removeSplitter ? 1 : 0;
            var counter = 0;
            // add empty element at start for using .Skip(1) at first group
            if (removeSplitter)
                list = new[] { default(T) }
                    .Concat(list)
                    .ToList();
            return list
                // add Index to each group
                .Select(c => new { Index = isSpliiter(c) ? ++counter : counter, Value = c })
                // group
                .GroupBy(pair => pair.Index)
                // transform each group to list and remove splitter if needed
                .Select(sub => sub.Select(c => c.Value).Skip(skip).ToList())
                .ToList();
        }
        public static List<T> Join<T>(this IList<List<T>> data, T splitter = default(T), bool putSplitter = false)
        {
            var splitterArr = new List<T>();
            if (putSplitter)
                splitterArr.Add(splitter);
            return data
                .SelectMany(line => splitterArr.Concat(line))
                .Skip(putSplitter ? 1 : 0)
                .ToList();
        }
        public static IEnumerable<T> SkipLast<T>(this IEnumerable<T> source, int n)
        {
            Queue<T> buffer = new Queue<T>(n + 1);
            foreach (T x in source)
            {
                buffer.Enqueue(x);
                if (buffer.Count == n + 1)
                {
                    yield return buffer.Dequeue();
                }
            }
        }
        public static string Plural(this string single)
        {
            var l = single.Length;
            switch (char.ToLowerInvariant(single[l - 1]))
            {
                case 'y':
                    return single.Substring(0, l - 1) + "ies";
                default:
                    return single + 's';
            }
        }
        public static bool IsNullOrNoneOrEmpty(this string str)
        {
            return string.IsNullOrEmpty(str) || str == RuntimeConstants.None;
        }
        public static T[] Merge<T>(this T[] first, params T[][] arrays)
        {
            var length = first.Length + arrays.Sum(array => array.Length);
            var result = new T[length];
            length = first.Length;
            Array.Copy(first, 0, result, 0, first.Length);
            foreach (var array in arrays)
            {
                Array.Copy(array, 0, result, length, array.Length);
                length += array.Length;
            }
            return result;
        }
        /// <summary>
        /// Returns distinct elements from a sequence according to a specified key selector function.
        /// </summary>
        /// <typeparam name="TSource">The type of the elements of source.</typeparam>
        /// <typeparam name="TKey">The type of the key returned by keySelector.</typeparam>
        /// <param name="source">The sequence to remove duplicate elements from.</param>
        /// <param name="keySelector">A function to extract the key for each element.</param>
        /// <returns>An <see cref="IEnumerable{T}"/> that contains distinct elements from the source sequence.</returns>
        public static IEnumerable<TSource> DistinctBy<TSource, TKey>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector)
        {
            if (source == null) throw new ArgumentNullException("source");
            if (keySelector == null) throw new ArgumentNullException("keySelector");
            return source.Distinct().GroupBy(keySelector).Select(group => group.First());
        }
        /// <summary>
        /// Produces the set difference of a sequence and a sequence generated using the specified item by using the default equality comparer to compare values.
        /// </summary>
        /// <typeparam name="TSource">The type of the elements of the input sequences.</typeparam>
        /// <param name="this">An <see cref="System.Collections.Generic.IEnumerable{T}"/> whose elements that are not also in second will be returned.</param>
        /// <param name="item">An item of type <typeparamref name="TSource"/> which, should it occur in the first sequence; will cause those elements to be removed from the returned sequence.</param>
        /// <returns>A sequence that contains the set difference of the elements of the specified sequence and a sequence built with the specified item.</returns>
        /// <exception cref="ArgumentNullException"><paramref name="this"/> or <paramref name="item"/> is <see langword="null"/>.</exception>
        public static IEnumerable<TSource> Except<TSource>(this IEnumerable<TSource> @this, TSource item)
        {
            if (@this == null) throw new ArgumentNullException("this");
            return @this.Except(new[] { item });
        }
        /// <summary>
        /// Returns the specified sequence with its items shuffled.
        /// </summary>
        /// <typeparam name="TSource">The type of the elements of the input sequences.</typeparam>
        /// <param name="this">The sequence which items will be shuffled.</param>
        /// <returns>Specified sequence with its items shuffled.</returns>
        /// <exception cref="ArgumentNullException"><paramref name="this"/> is <see langword="null"/>.</exception>
        /// <remarks>Due to the very nature of shuffling, this method does not use deferred execution.</remarks>
        public static IEnumerable<TSource> Shuffle<TSource>(this IEnumerable<TSource> @this)
        {
            if (@this == null) throw new ArgumentNullException("this");
            return @this.Shuffle(new Random());
        }
        /// <summary>
        /// Returns the specified sequence with its items shuffled using the specified random number generator.
        /// </summary>
        /// <typeparam name="TSource">The type of the elements of the input sequences.</typeparam>
        /// <param name="this">The sequence which items will be shuffled.</param>
        /// <param name="random">The random number generator used to shuffle the input sequence items.</param>
        /// <returns>Specified sequence with its items shuffled.</returns>
        /// <exception cref="ArgumentNullException"><paramref name="this"/> or <paramref name="random"/> is <see langword="null"/>.</exception>
        /// <remarks>Due to the very nature of shuffling, this method does not use deferred execution.</remarks>
        public static IEnumerable<TSource> Shuffle<TSource>(this IEnumerable<TSource> @this, Random random)
        {
            if (@this == null) throw new ArgumentNullException("this");
            if (random == null) throw new ArgumentNullException("random");
            var buffer = @this.ToList();
            for (var i = 0; i < buffer.Count; i++)
            {
                var j = random.Next(i, buffer.Count);
                yield return buffer[j];
                buffer[j] = buffer[i];
            }
        }
        /// <summary>
        /// Returns a dictionary of key value pairs built upon the specified sequence of such key value pairs (<see cref="KeyValuePair{T, U}"/>).
        /// </summary>
        /// <typeparam name="TKey">The type of the keys.</typeparam>
        /// <typeparam name="TValue">The type of the values.</typeparam>
        /// <param name="this">The sequence which will be converted to a dictionary.</param>
        /// <returns>Dictionary of key value pairs built upon the specified sequence of such key value pairs (<see cref="KeyValuePair{T, U}"/>)..</returns>
        /// <exception cref="ArgumentNullException"><paramref name="this"/> is <see langword="null"/>.</exception>
        /// <exception cref="ArgumentException"><paramref name="this"/> contains several instances of a key.</exception>
        /// <remarks>As we need to check if keys are unique, this method does not used deferred execution.</remarks>
        public static IDictionary<TKey, TValue> ToDictionary<TKey, TValue>(this IEnumerable<KeyValuePair<TKey, TValue>> @this)
        {
            if (@this == null) throw new ArgumentNullException("this");
            @this = @this.ToArray();
            if (@this.Select(kvp => kvp)
                     .GroupBy(kvp => kvp.Key)
                     .Any(kvpGroup => kvpGroup.Count() > 1))
            {
                throw new ArgumentException("the specified sequence contains several instances of a key", "this");
            }
            return @this.ToDictionary(kvp => kvp.Key, kvp => kvp.Value);
        }
        public static void RemoveAll<TKey, TValue>(this IDictionary<TKey, TValue> dic, Func<TKey, bool> filter)
        {
            var keys = dic.Keys.Where(filter).ToList();
            foreach (var key in keys)
            {
                dic.Remove(key);
            }
        }
        public delegate bool Comparer<T>(T item1, T item2);
        /// <summary>
        /// From a list like [a,b,c] constructs a list [f(a),f(b),f(c)]
        /// </summary>
        public static List<R> Map<T, R>(IEnumerable<T> items, Func<T, R> functor)
        {
            var result = new List<R>();
            foreach (T item in items)
            {
                result.Add(functor(item));
            }
            return result;
        }
        public static List<R> SafeMap<T, R>(IEnumerable<T> items, Func<T, R> functor)
        {
            var result = new List<R>();
            foreach (T item in items)
            {
                try
                {
                    result.Add(functor(item));
                }
                catch
                {
                }
            }
            return result;
        }
        /// <summary>
        /// From a collection like [a,b,c] constructs an array [f(a),f(b),f(c)]
        /// </summary>
        public static R[] MapToArray<T, R>(ICollection<T> items, Func<T, R> functor)
        {
            var result = new R[items.Count];
            var i = 0;
            foreach (T item in items)
            {
                result[i++] = functor(item);
            }
            return result;
        }
        /// <summary>
        /// From a list like [a,b,c] constructs a dictionary like [f(a) => a, f(b) => b, f(c) => c]
        /// </summary>
        public static Dictionary<K, T> Index<K, T>(IEnumerable<T> items, Func<T, K> extractKey)
        {
            var result = new Dictionary<K, T>();
            foreach (T item in items)
            {
                result.Add(extractKey(item), item);
            }
            return result;
        }
        public static List<R> RecursivSuite<R, T>(IEnumerable<T> indexes, Func<R, T, R> next, R firstValue)
        {
            var result = new List<R> { firstValue };
            R previousValue = firstValue;
            foreach (T index in indexes)
            {
                R newValue = next(previousValue, index);
                result.Add(newValue);
                previousValue = newValue;
            }
            return result;
        }
        public static void ForEachPair<T>(IEnumerable<T> items, Handler<T, T> doSomething)
        {
            Check.ArgumentNotNull(items, "items");
            Check.ArgumentNotNull(doSomething, "doSomething");
            IEnumerator<T> enumerator = items.GetEnumerator();
            enumerator.Reset();
            if (!enumerator.MoveNext())
                return;
            T previous = enumerator.Current;
            while (enumerator.MoveNext())
            {
                doSomething(previous, enumerator.Current);
                previous = enumerator.Current;
            }
        }
        public static T FindFirst<T>(IEnumerable<T> items, Predicate<T> predicate)
        {
            foreach (T item in items)
            {
                if (predicate(item))
                    return item;
            }
            return default(T);
        }
        public static Dictionary<K, T> Clone<K, T>(IDictionary<K, T> dico)
        {
            Check.Argument(dico is IDictionary);
            var copy = new Dictionary<K, T>();
            CopyTo(dico, copy);
            return copy;
        }
        public static void CopyTo<K, T>(IDictionary<K, T> from, IDictionary<K, T> to)
        {
            Check.ArgumentNotNull(from, "from");
            Check.ArgumentNotNull(to, "to");
            foreach (KeyValuePair<K, T> pair in from)
            {
                to[pair.Key] = pair.Value;
            }
        }
        public static Dictionary<K, T> DeepCloneCloneableOfT<K, T>(IDictionary<K, T> dico)
            where K : ICloneable<K>
            where T : ICloneable<T>
        {
            Check.Argument(dico is IDictionary);
            var copy = new Dictionary<K, T>();
            DeepCopyToCloneableOfT(dico, copy);
            return copy;
        }
        public static void DeepCopyToCloneableOfT<K, T>(IDictionary<K, T> from, IDictionary<K, T> to)
            where K : ICloneable<K>
            where T : ICloneable<T>
        {
            Check.ArgumentNotNull(from, "from");
            Check.ArgumentNotNull(to, "to");
            foreach (KeyValuePair<K, T> pair in from)
            {
                to[pair.Key.Clone()] = pair.Value.Clone();
            }
        }
        public static Dictionary<K, T> DeepCloneCloneable<K, T>(IDictionary<K, T> dico)
            where K : ICloneable
            where T : ICloneable
        {
            Check.Argument(dico is IDictionary);
            var copy = new Dictionary<K, T>();
            DeepCopyToCloneable(dico, copy);
            return copy;
        }
        public static void DeepCopyToCloneable<K, T>(IDictionary<K, T> from, IDictionary<K, T> to)
            where K : ICloneable
            where T : ICloneable
        {
            Check.ArgumentNotNull(from, "from");
            Check.ArgumentNotNull(to, "to");
            foreach (KeyValuePair<K, T> pair in from)
            {
                to[(K)pair.Key.Clone()] = (T)pair.Value.Clone();
            }
        }
        // From http://www.codeproject.com/KB/recipes/DeepCloneDictionary.aspx
        //
        /// <summary>
        /// Creates a copy of a dictionary by serializing and deserializing it.
        /// </summary>
        /// <remarks>Objects must be serializable (See <see cref="SerializableAttribute"/>)</remarks>
        public static Dictionary<K, V> DeepCloneDictionaryBySerialization<K, V>(IEnumerable<KeyValuePair<K, V>> dict)
        {
            // The clone method is immune to the source dictionary being null.
            if (dict == null)
                return null;
            // If the key and value are value types, clone without serialization.
            if (((typeof(K).IsValueType || typeof(K) == typeof(string)) &&
                 (typeof(V).IsValueType) || typeof(V) == typeof(string)))
            {
                var result = new Dictionary<K, V>();
                // Clone by copying the value types.
                foreach (var kvp in dict)
                {
                    result[kvp.Key] = kvp.Value;
                }
                return result;
            }
            // Clone by serializing to a memory stream, then deserializing.
            // Don't use this method if you've got a large objects, as the
            // BinaryFormatter produces bloat, bloat, and more bloat.
            var formatter = new BinaryFormatter();
            using (var stream = new PooledMemoryStream())
            {
                formatter.Serialize(stream, dict);
                stream.Position = 0;
                var result = (Dictionary<K, V>)formatter.Deserialize(stream);
                return result;
            }
        }
        public static void TransformTo<K, T, U>(IDictionary<K, T> from, IDictionary<K, U> to, Func<T, U> transform)
        {
            Check.ArgumentNotNull(from, "from");
            Check.ArgumentNotNull(to, "to");
            foreach (KeyValuePair<K, T> pair in from)
            {
                to[pair.Key] = transform(pair.Value);
            }
        }
        public static ISet<K> Clone<K>(ISet<K> set)
        {
            ISet<K> copy = new Set<K>();
            foreach (K k in set)
            {
                copy.Add(k);
            }
            return copy;
        }
        public static bool AreEqual(IEnumerable list1, IEnumerable list2)
        {
            return AreEqual(list1, list2, Equals);
        }
        public static bool AreEqual(IEnumerable list1, IEnumerable list2, Comparer<Object> itemsAreEqual)
        {
            if (list1 == list2)
                return true;
            if ((null == list1) || (null == list2))
                return false;
            IEnumerator iterator1 = list1.GetEnumerator();
            IEnumerator iterator2 = list2.GetEnumerator();
            try
            {
                iterator1.Reset();
            }
            catch (NotSupportedException)
            {
                // Some iterators (e.g. ErrorsList iterator) do not support Reset():
                // Just assume GetEnumerator() returns an iterator at the beginning.
            }
            try
            {
                iterator2.Reset();
            }
            catch (NotSupportedException)
            {
                // Some iterators (e.g. ErrorsList iterator) do not support Reset():
                // Just assume GetEnumerator() returns an iterator at the beginning.
            }
            bool notFinished1 = iterator1.MoveNext();
            bool notFinished2 = iterator2.MoveNext();
            while (notFinished1 && notFinished2)
            {
                if (!itemsAreEqual(iterator1.Current, iterator2.Current))
                    return false;
                notFinished1 = iterator1.MoveNext();
                notFinished2 = iterator2.MoveNext();
            }
            return (notFinished1 == notFinished2);
        }
        public static bool AreEqualUnordered<T>(IEnumerable<T> list1, IEnumerable<T> list2)
        {
            if (list1 == list2)
                return true;
            if ((null == list1) || (null == list2))
                return false;
            var left = new List<T>(list1);
            foreach (T t in list2)
            {
                int index = left.IndexOf(t);
                if (index < 0)
                {
                    return false;
                }
                else
                {
                    left.RemoveAt(index);
                }
            }
            return (left.Count == 0);
        }
        public static bool AreEqualUnordered(IEnumerable list1, IEnumerable list2)
        {
            if (list1 == list2)
                return true;
            if ((null == list1) || (null == list2))
                return false;
            var left = new List<object>();
            foreach (var obj in list1)
            {
                left.Add(obj);
            }
            foreach (var obj in list2)
            {
                int index = left.IndexOf(obj);
                if (index < 0)
                {
                    return false;
                }
                else
                {
                    left.RemoveAt(index);
                }
            }
            return (left.Count == 0);
        }
        /// <summary>
        ///  Quadratic function, do not compare too big lists
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="list1"></param>
        /// <param name="list2"></param>
        /// <param name="comparer"></param>
        /// <returns></returns>
        public static bool AreEqualUnordered<T>(IEnumerable<T> list1, IEnumerable<T> list2, Comparer<T> comparer)
        {
            if (ReferenceEquals(list1, list2))
                return true;
            if ((null == list1) || (null == list2))
                return false;
            var left = new List<T>(list1);
            foreach (T t2 in list2)
            {
                bool found = false;
                for (int i = 0; i < left.Count; ++i)
                {
                    if (comparer(t2, left[i]))
                    {
                        found = true;
                        left.RemoveAt(i);
                        break;
                    }
                }
                if (!found)
                    return false;
            }
            return (left.Count == 0);
        }
        public static bool AreDictionariesEqual<K, T>(IDictionary<K, T> dico1, IDictionary<K, T> dico2)
        {
            return AreDictionariesEqual(dico1, dico2, (v1, v2) => Equals(v1, v2));
        }
        public static bool AreDictionariesEqual<K, T>(IDictionary<K, T> dico1, IDictionary<K, T> dico2, Comparer<T> valuesAreEqual)
        {
            if (dico1 == dico2)
                return true;
            if (dico1 == null || dico2 == null || dico1.Count != dico2.Count)
                return false;
            foreach (var entry in dico1)
            {
                T value2;
                if (!dico2.TryGetValue(entry.Key, out value2))
                    return false;
                if (!valuesAreEqual(entry.Value, value2))
                    return false;
            }
            return true;
        }
        public static bool AreDictionariesEqual<K, T>(IDictionary<K, IList<T>> dico1, IDictionary<K, IList<T>> dico2)
        {
            return AreDictionariesEqual(dico1, dico2, AreEqual);
        }
        public const String NULL_OBJECT_TO_STRING = "nothing";
        public static void ForEachAndBetween<T>(IEnumerable values, Handler betweenAction, Action<T> action)
        {
            Check.ArgumentNotNull(action, "action");
            Check.ArgumentNotNull(betweenAction, "betweenAction");
            if (null == values)
                return;
            var isFirstItem = true;
            foreach (T value in values)
            {
                if (isFirstItem)
                {
                    isFirstItem = false;
                }
                else
                {
                    betweenAction();
                }
                action(value);
            }
        }
        public delegate String ToStringDelegate<T>(T obj);
        public static String ToString<T>(IEnumerable values, String prefix, string between, ToStringDelegate<T> itemToString, String suffix)
        {
            if (null == values)
                return NULL_OBJECT_TO_STRING;
            var result = new StringBuilder();
            result.Append(prefix);
            ForEachAndBetween<T>(values
                                 , () => result.Append(between)
                                 , value => result.Append(itemToString(value))
                );
            result.Append(suffix);
            return result.ToString();
        }
        public static String ToString(IEnumerable values, String prefix, string between, String suffix)
        {
            return ToString<Object>(values, prefix, between, obj => obj.ToString(), suffix);
        }
        public static String ToString<T>(IEnumerable values, ToStringDelegate<T> itemToString)
        {
            return ToString(values, "[", ";", itemToString, "]");
        }
        public static String ToString(IEnumerable values)
        {
            return ToString<object>(values
                                    , value => (value == null ? "" : value.ToString())
                );
        }
        public static String ToString<K, T>(IDictionary<K, T> keyValues, ToStringDelegate<T> valueToString)
        {
            Check.ArgumentNotNull(valueToString, "valueToString");
            return ToString<KeyValuePair<K, T>>(keyValues
                                                , keyValue => keyValue.Key + "=>" + valueToString(keyValue.Value)
                );
        }
        public static String ToString<K, T>(IDictionary<K, T> keyValues)
        {
            return ToString(keyValues, obj => obj.ToString());
        }
        public static String ToString<K, T>(IDictionary<K, IList<T>> keyValues)
        {
            return ToString(keyValues, delegate(IList<T> obj)
            {
                return ToString(obj);
            });
        }
        public static bool Contains<T>(IEnumerable<T> values, Predicate<T> predicate)
        {
            foreach (T value in values)
            {
                if (predicate(value))
                    return true;
            }
            return false;
        }
        public static T[] ToArray<T>(ICollection<T> collection)
        {
            return ToArrayOf<T, T>(collection);
        }
        public static T[] ToArrayOf<T, U>(ICollection<U> collection) where T : U
        {
            var result = new T[collection.Count];
            var i = 0;
            foreach (U item in collection)
            {
                result[i] = (T)item;
                i++;
            }
            return result;
        }
        /// <summary>
        /// Iterates simultaneously over two lists, calling a delegate on each pair.
        /// </summary>
        /// <throws>ArgumentException if the two lists have different lengthes</throws>
        public static void Foreach<T, U>(ICollection<T> list1, ICollection<U> list2, Handler<T, U> doSomething)
        {
            Check.ArgumentNotNull(list1, "list1");
            Check.ArgumentNotNull(list2, "list2");
            Check.Argument(list1.Count == list2.Count);
            IEnumerator<T> enum1 = list1.GetEnumerator();
            enum1.Reset();
            IEnumerator<U> enum2 = list2.GetEnumerator();
            enum2.Reset();
            while (enum1.MoveNext() && enum2.MoveNext())
            {
                doSomething(enum1.Current, enum2.Current);
            }
        }
        /// <summary>
        /// Add foreach with an index as parameter
        /// http://stackoverflow.com/questions/521687/c-sharp-foreach-with-index
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="ie"></param>
        /// <param name="action"></param>
        public static void ForEach<T>(this IEnumerable<T> ie, Action<T, int> action)
        {
            var i = 0;
            foreach (var e in ie) action(e, i++);
        }
        public static void ForEach<T>(this IEnumerable<T> ie, Action<T> action)
        {
            foreach (var e in ie) action(e);
        }
        public static IEnumerable<U> Enumerate<T, U>(IEnumerable<T> list, Predicate<T> predicate)
            where U : class
        {
            Check.ArgumentNotNull(list, "List");
            IEnumerator<T> enumerator = list.GetEnumerator();
            while (enumerator.MoveNext())
            {
                T current = enumerator.Current;
                if (predicate(current))
                    yield return current as U;
            }
        }
        public static IEnumerable<IEnumerable<T>> EnumerateByBucket<T>(IEnumerable<T> items, int bucketSize)
        {
            Check.ArgumentNotNull(items, "items");
            var subList = new List<T>(bucketSize);
            IEnumerator<T> enumerator = items.GetEnumerator();
            do
            {
                subList.Clear();
                subList.AddRange(Enumerate(enumerator, bucketSize));
                if (subList.Count == 0)
                    yield break;
                yield return subList;
            }
            while (subList.Count > 0);
        }
        private static IEnumerable<T> Enumerate<T>(IEnumerator<T> enumerator, int maxEnumerable)
        {
            int i = 0;
            while (i < maxEnumerable && enumerator.MoveNext())
            {
                T current = enumerator.Current;
                yield return current;
                i++;
            }
        }
        public static T FirstOf<T>(IEnumerable<T> items)
        {
            Check.ArgumentNotNull(items, "items");
            IEnumerator<T> enumerator = items.GetEnumerator();
            enumerator.Reset();
            if (!enumerator.MoveNext())
                throw new ArgumentException("Collection is empty", "items");
            T result = enumerator.Current;
            return result;
        }
        public static ICollection<T> Intersection<T>(ICollection<T> list1, ICollection<T> list2)
        {
            var result = new List<T>();
            foreach (T item in list1)
            {
                if (list2.Contains(item))
                {
                    result.Add(item);
                }
            }
            return result;
        }
        public static IEnumerable<T> Intersection<T>(this ICollection<T> @this, ICollection<T> otherList, Func<T, T, bool> compare)
        {
            foreach (T item in @this)
            {
                if (otherList.Any(otherItemm => compare(item, otherItemm)))
                {
                    yield return item;
                }
            }
        }
        public static ICollection<T> Minus<T>(ICollection<T> listSource, ICollection<T> listRemove)
        {
            var result = new List<T>(listSource);
            foreach (T item in listSource)
            {
                if (listRemove.Contains(item))
                {
                    result.Remove(item);
                }
            }
            return result;
        }
        public static ICollection<T> GetChangedItems<T, TKey>(ICollection<T> newList, ICollection<T> oldList, Func<T, TKey> getKey, out ICollection<T> newItems, out ICollection<T> deletedItems)
        {
            Check.NotNull(newList);
            Check.NotNull(oldList);
            Dictionary<TKey, T> oldItemsDict = new Dictionary<TKey, T>(oldList.Count);
            foreach (T item in oldList)
            {
                TKey key = getKey(item);
                if (oldItemsDict.ContainsKey(key))
                    throw new InvalidOperationException("Old list of objects containing a duplicated key " + key);
                oldItemsDict[getKey(item)] = item;
            }
            Set<TKey> notDeletedKeys = new Set<TKey>();
            ICollection<T> result = new List<T>();
            newItems = new List<T>();
            T foundOldItem;
            // fill new item
            foreach (T newItem in newList)
            {
                TKey keyNewItem = getKey(newItem);
                notDeletedKeys.Add(keyNewItem);
                if (oldItemsDict.TryGetValue(keyNewItem, out foundOldItem))
                {
                    if (!foundOldItem.Equals(newItem))
                    {
                        result.Add(newItem);
                    }
                }
                else
                {
                    newItems.Add(newItem);
                }
            }
            // fill deleted itmes list
            deletedItems = new List<T>();
            foreach (var oldKey in oldItemsDict.Keys)
            {
                if (!notDeletedKeys.Contains(oldKey))
                {
                    deletedItems.Add(oldItemsDict[oldKey]);
                }
            }
            return result;
        }
        public static ICollection<T> Union<T>(ICollection<T> list1, ICollection<T> list2)
        {
            var result = new Set<T>();
            foreach (T item in list1)
            {
                result.Add(item);
            }
            foreach (T item in list2)
            {
                result.Add(item);
            }
            return new List<T>(result);
        }
        public static bool CheckAreEquals<T>(IEnumerable<T> set1, IEnumerable<T> set2, Comparer<T> comparer, Handler<T> onItemMissingInSet1, Handler<T> onItemMissingInSet2)
        {
            var ok = true;
            ok &= CheckContains(set2, set1, comparer, onItemMissingInSet1);
            ok &= CheckContains(set1, set2, comparer, onItemMissingInSet2);
            return ok;
        }
        public static bool CheckContains<T>(IEnumerable<T> set, IEnumerable<T> subSet)
            where T : class
        {
            return CheckContains(set, subSet, delegate(T item1, T item2)
            {
                if (item1 == null || item2 == null)
                    return (item1 == null && item2 == null);
                return item1.Equals(item2);
            }, null);
        }
        public static bool CheckContains<T>(IEnumerable<T> set, IEnumerable<T> subSet, Comparer<T> comparer, Handler<T> onItemMissingInSet)
        {
            if (set == null || subSet == null)
                return (set == null && subSet == null);
            var ok = true;
            foreach (T item1 in subSet)
            {
                var found = false;
                foreach (T item2 in set)
                {
                    if (comparer(item1, item2))
                    {
                        found = true;
                        break;
                    }
                }
                if (!found)
                {
                    ok = false;
                    if (onItemMissingInSet != null)
                        onItemMissingInSet(item1);
                }
            }
            return ok;
        }
        /// <summary>
        ///
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="list"></param>
        /// <param name="comparer"></param>
        /// <param name="OnDuplicateEntryFound">return true if entry is removed from the list, false otherwise</param>
        /// <param name="OnNewItemProcessed">can be null</param>
        public static void SearchDuplicateEntries<T>(IList<T> list, Comparer<T> comparer, Func<Int32, T, Boolean> OnDuplicateEntryFound, Handler<Int32, T> OnNewItemProcessed)
        {
            int i = 0;
            while (i < list.Count)
            {
                T item = list[i];
                if (OnNewItemProcessed != null)
                    OnNewItemProcessed(i, item);
                // Not very optimized but the list is large so it takes care of memory usage like ..
                int j = i + 1;
                while (j < list.Count)
                {
                    T itemBis = list[j];
                    if (comparer(item, itemBis))
                    {
                        if (OnDuplicateEntryFound(j, itemBis))
                            continue;
                    }
                    j++;
                }
                i++;
            }
        }
        public static bool Contains(this IEnumerable<string> target, string value, StringComparison comparisonType)
        {
            return target.Any(item => item.Equals(value, comparisonType));
        }
        public static int IndexOfOrMax<T>(this IList<T> @this, T item)
        {
            return @this.IndexOfOrDefault(item, int.MaxValue);
        }
        public static int IndexOfOrDefault<T>(this IList<T> @this, T item, int defaultValue)
        {
            var index = @this.IndexOf(item);
            return index == -1 ? defaultValue : index;
        }
        /* Algorithm by Donald Knuth. */
        /// <summary>
        /// Get combination of k element from a list of elements
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="list"></param>
        /// <param name="k"></param>
        /// <returns></returns>
        public static IList<List<T>> GetCombinationsOf_k<T>(IList<T> list, int k)
        {
            Check.NotNull(list);
            Check.That(k >= 0);
            IList<List<T>> result = new List<List<T>>();
            if (k == 0)
                return result;
            if (k == list.Count)
            {
                result.Add(new List<T>(list));
                return result;
            }
            int i, j, x;
            var c = new int[k + 3];
            int n = list.Count;
            for (i = 1; i <= k; i++) c[i] = i;
            c[k + 1] = n + 1;
            c[k + 2] = 0;
            j = k;
        visit:
            var combination = new List<T>();
            for (i = k; i >= 1; i--)
            {
                combination.Add(list[c[i] - 1]);
            }
            result.Add(combination);
            if (j > 0) { x = j + 1; goto incr; }
            if (c[1] + 1 < c[2])
            {
                c[1] += 1;
                goto visit;
            }
            j = 2;
        do_more:
            c[j - 1] = j - 1;
            x = c[j] + 1;
            if (x == c[j + 1]) { j++; goto do_more; }
            if (j > k) return result;
        incr:
            c[j] = x;
            j--;
            goto visit;
        }
        public static void MergeDictionary<T, U>(Dictionary<T, U> mergeTarget, Dictionary<T, U> itemsToMerge)
        {
            Check.NotNull(mergeTarget);
            Check.NotNull(itemsToMerge);
            foreach (var keyValue in itemsToMerge)
            {
                mergeTarget[keyValue.Key] = keyValue.Value;
            }
        }
        public static List<List<T>> SplitInListOfList<T>(IEnumerable<T> listToSplit, int blockSize)
        {
            Check.NotNull(listToSplit);
            Check.That(blockSize > 0);
            List<List<T>> listOfSplittedList = new List<List<T>>();
            int lotSize = blockSize;
            List<T> currentSplitFilterContent = new List<T>(blockSize);
            foreach (var item in listToSplit)
            {
                if (currentSplitFilterContent.Count < lotSize)
                {
                    currentSplitFilterContent.Add(item);
                }
                else
                {
                    listOfSplittedList.Add(currentSplitFilterContent);
                    currentSplitFilterContent = new List<T>(blockSize);
                    currentSplitFilterContent.Add(item);
                }
            }
            if (currentSplitFilterContent.Count > 0)
            {
                listOfSplittedList.Add(currentSplitFilterContent);
            }
            return listOfSplittedList;
        }
        private enum BoundType { Lower, Upper }
        private static int Dichotomy<Key>(IList<Key> keys, Key key, int min, int max, BoundType boundType, IComparer<Key> comparer)
        {
            if (max - min <= 1)
                return boundType == BoundType.Lower ? min : max;
            int mid = (min + max) / 2;
            int compare = comparer.Compare(key, keys[mid]);
            if (compare == 0)
                return mid;
            if (compare > 0)
                return Dichotomy(keys, key, mid, max, boundType, comparer);
            return Dichotomy(keys, key, min, mid, boundType, comparer);
        }
        private static bool Bound<Key, Value>(this SortedList<Key, Value> list, Key key, BoundType boundType, out KeyValuePair<Key, Value> bound)
        {
            if (list.Count == 0)
            {
                bound = default(KeyValuePair<Key, Value>);
                return false;
            }
            IList<Key> keys = list.Keys;
            int compareFirst = list.Comparer.Compare(keys[0], key);
            if (compareFirst >= 0)
            {
                bound = new KeyValuePair<Key, Value>(keys[0], list.Values[0]);
                return boundType == BoundType.Upper || compareFirst == 0;
            }
            int compareLast = list.Comparer.Compare(keys[keys.Count - 1], key);
            if (compareLast <= 0)
            {
                bound = new KeyValuePair<Key, Value>(keys[keys.Count - 1], list.Values[keys.Count - 1]);
                return boundType == BoundType.Lower || compareLast == 0;
            }
            int boundIndex = Dichotomy(keys, key, 0, keys.Count - 1, boundType, list.Comparer);
            bound = new KeyValuePair<Key, Value>(keys[boundIndex], list.Values[boundIndex]);
            return true;
        }
        public static bool LowerBound<Key, Value>(this SortedList<Key, Value> list, Key key, out KeyValuePair<Key, Value> lowerBound)
        {
            return Bound(list, key, BoundType.Lower, out lowerBound);
        }
        public static bool UpperBound<Key, Value>(this SortedList<Key, Value> list, Key key, out KeyValuePair<Key, Value> upperBound)
        {
            return Bound(list, key, BoundType.Upper, out upperBound);
        }
        public static bool IsNullOrEmpty<T>(this IEnumerable<T> @this)
        {
            return (@this == null) || (!@this.Any());
        }
        public static bool IsNotNullNorEmpty<T>(this IEnumerable<T> @this)
        {
            return !@this.IsNullOrEmpty();
        }
        public static void SafeEnumerator<T>(IEnumerator<T> en, Action<T> onSuccess, Action<Exception> onError, LogHelper logger)
        {
            bool hasNext = true;
            while (hasNext)
            {
                try
                {
                    if ((hasNext = en.MoveNext()) == true)
                    {
                        onSuccess(en.Current);
                    }
                }
                catch (Exception ex)
                {
                    try
                    {
                        onError(ex);
                    }
                    catch (Exception ex2)
                    {
                        if (logger != null)
                            logger.Error("SafeEnumerator: first I had :" + ex + Environment.NewLine + "...then I had, while trying to fire error: " + ex2);
                    }
                }
            }
        }
    }
}
============
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Text;
using System.ComponentModel;
using System.Xml.Serialization;
using Sgcib.TOne.ComponentModel;
namespace Sgcib.TOne.Util
{
    public static class EnumHelper
    {
        public static IEnumerable<T> Values<T> ()
        {
            return Enum.GetValues(typeof(T)).Cast<T>();
        }
        public static List<IEnumDefaulting> EnumDefaultings = new List<IEnumDefaulting>();
        #region EnumDefaultingHelper
        private static string GetDefaultValue(Type enumType, string unexpectedValue)
        {
            foreach (var e in EnumDefaultings)
            {
                if (e.GetEnumType() != null)
                    if (e.GetEnumType().Equals(enumType) && e.GetUnexpectedValue().Equals(unexpectedValue))
                        return e.GetDefaultValue();
            }
            return String.Empty;
        }
        #endregion
        public static T SafeParse<T>(string stringValue)
        {
            if (!Enum.IsDefined(typeof(T), stringValue))
            {
                stringValue = GetDefaultValue(typeof(T), stringValue);
                if (String.IsNullOrEmpty(stringValue))
                    throw new NotSupportedException(string.Format("The value {0} is not supported for type {1}", stringValue, typeof(T)));
            }
            return (T)Enum.Parse(typeof(T), stringValue);
        }
        public static bool TryParse<T>(string stringValue, out T parsedEnum)
        {
            if (!Enum.IsDefined(typeof(T), stringValue))
            {
                stringValue = GetDefaultValue(typeof(T), stringValue);
                if (String.IsNullOrEmpty(stringValue))
                {
                    parsedEnum = (T)Enum.Parse(typeof(T), Enum.GetNames(typeof(T))[0]);
                    return false;
                }
            }
            parsedEnum = (T)Enum.Parse(typeof(T), stringValue);
            return true;
        }
        public static bool TryParseNullable<T>(string stringValue, out T? parsedEnum) where T : struct
        {
            if (!Enum.IsDefined(typeof(T), stringValue))
            {
                stringValue = GetDefaultValue(typeof(T), stringValue);
                if (String.IsNullOrEmpty(stringValue))
                {
                    parsedEnum = null;
                    return false;
                }
            }
            parsedEnum = (T)Enum.Parse(typeof(T), stringValue);
            return true;
        }
        /// <summary>
        /// Parsing d'un Enum
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="stringValue">string  parser</param>
        /// <param name="valueIfNotValid">valeur  donner si Enum non dfini</param>
        /// <returns></returns>
        public static T SafeParse<T>(string stringValue, T valueIfNotValid)
        {
            return SafeParse(stringValue, valueIfNotValid, false);
        }
        /// <summary>
        /// Parsing d'un Enum
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="stringValue">string  parser</param>
        /// <param name="valueIfNotValid">valeur  donner si Enum non dfini</param>
        /// <param name="isPrefixedByTypeName"></param>
        /// <returns></returns>
        public static T SafeParse<T>(string stringValue, T valueIfNotValid, bool isPrefixedByTypeName)
        {
            string valueToParse = stringValue;
            if (isPrefixedByTypeName)
            {
                valueToParse = stringValue.Replace(typeof(T).Name + ".", string.Empty);
            }
            if (String.IsNullOrEmpty(valueToParse) || !Enum.IsDefined(typeof(T), valueToParse))
            {
                return valueIfNotValid;
            }
            return (T)Enum.Parse(typeof(T), valueToParse);
        }
        /// <summary>
        /// Parsing of an enum from the underlying value
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="stringValue">value to parse</param>
        /// <param name="valueIfNotValid">enum value if not defined</param>
        /// <returns></returns>
        public static T SafeParseValue<T>(string stringValue, T valueIfNotValid)
        {
            char chrValue;
            T obj = valueIfNotValid;
            if (!string.IsNullOrEmpty(stringValue))
            {
                if (char.TryParse(stringValue, out chrValue))
                    obj = (T)Enum.ToObject(typeof(T), chrValue);
            }
            if (!Enum.IsDefined(typeof(T), obj))
                obj = valueIfNotValid;
            return obj;
        }
// ReSharper disable InconsistentNaming
        public static T DBParse<T>(string stringValue, T nullValue)
// ReSharper restore InconsistentNaming
        {
            if (String.IsNullOrEmpty(stringValue))
                return nullValue;
            return (T)Enum.Parse(typeof(T), stringValue);
        }
        /// <summary>
        /// Return the string value defined by the <see cref="StringValueAttribute"/> attribute.
        /// </summary>
        /// <param name="enumValue">The enum value</param>
        /// <returns>The string value defined for the enum value, null if no StringValueAttribute is found for the given enum value</returns>
        public static string GetStringValue(Enum enumValue)
        {
            return GetStringValueInternal(enumValue);
        }
        internal static string GetStringValueInternal(object enumValue)
        {
            Type enumType = enumValue.GetType();
            FieldInfo fi = enumType.GetField(enumValue.ToString());
            var attrs = fi.GetCustomAttributes(typeof(StringValueAttribute), false) as StringValueAttribute[];
            if (attrs != null && attrs.Length > 0)
            {
                return attrs[0].Value;
            }
            return null;
        }
        /// <summary>
        /// Return the description defined by the <see cref="DescriptionAttribute"/> attribute.
        /// </summary>
        /// <param name="enumValue">The enum value</param>
        /// <returns>The description defined for the enum value, null if no DescriptionAttribute is found for the given enum value</returns>
        public static string GetDescription(Enum enumValue)
        {
            return GetDescription(enumValue, false);
        }
        /// <summary>
        /// Return the description defined by the <see cref="DescriptionAttribute"/> attribute.
        /// </summary>
        /// <param name="enumValue">The enum value</param>
        /// <param name="returnNameIfNoAttributeFound"></param>
        /// <returns>The description defined for the enum value, the enum value name if no DescriptionAttribute is found for the given enum value</returns>
        public static string GetDescription(Enum enumValue, bool returnNameIfNoAttributeFound)
        {
            return GetDescription(enumValue.GetType(), enumValue.ToString(), returnNameIfNoAttributeFound);
        }
        /// <summary>
        /// Return the description defined by the <see cref="DescriptionAttribute"/> attribute.
        /// </summary>
        /// <param name="enumType">The enum type</param>
        /// <param name="enumValue">The enum string value</param>
        /// <param name="returnNameIfNoAttributeFound"></param>
        /// <returns>The description defined for the enum value, the enum value name if no DescriptionAttribute is found for the given enum value</returns>
        public static string GetDescription(Type enumType, string enumValue, bool returnNameIfNoAttributeFound)
        {
            FieldInfo fi = enumType.GetField(enumValue);
            if (fi != null)
            {
                DescriptionAttribute[] attrs = fi.GetCustomAttributes(typeof(DescriptionAttribute), false) as DescriptionAttribute[];
                if (attrs != null && attrs.Length > 0)
                {
                    return attrs[0].Description;
                }
                return returnNameIfNoAttributeFound ? fi.Name : null;
            }
            return null;
        }
        /// <summary>
        /// Parse the string value and return the associated enum value
        /// </summary>
        /// <param name="enumType">The enum type</param>
        /// <param name="stringValue">The string value to parse</param>
        /// <param name="ignoreCase">Ignore case for parsing</param>
        /// <returns>The found enum value, null otherwise</returns>
        public static object ParseStringValue(Type enumType, string stringValue, bool ignoreCase)
        {
            StringValueAttribute[] currentAttrs;
            if (!enumType.IsEnum)
            {
                throw new ArgumentException(String.Format("Given type must be an Enum. Type was {0}", enumType.FullName));
            }
            foreach (FieldInfo currentFieldInfo in enumType.GetFields())
            {
                currentAttrs = currentFieldInfo.GetCustomAttributes(typeof(StringValueAttribute), false) as StringValueAttribute[];
                if (currentAttrs != null && currentAttrs.Length > 0 && String.Compare(currentAttrs[0].Value, stringValue, ignoreCase) == 0)
                {
                    return Enum.Parse(enumType, currentFieldInfo.Name);
                }
            }
            // In case we don't find any corresponding, maybe stringValue is a too new value => use defaulting system
            stringValue = GetDefaultValue(enumType, stringValue);
            if (!String.IsNullOrEmpty(stringValue))
            {
                foreach (FieldInfo currentFieldInfo in enumType.GetFields())
                {
                    currentAttrs = currentFieldInfo.GetCustomAttributes(typeof(StringValueAttribute), false) as StringValueAttribute[];
                    if (currentAttrs != null && currentAttrs.Length > 0 && String.Compare(currentAttrs[0].Value, stringValue, ignoreCase) == 0)
                    {
                        return Enum.Parse(enumType, currentFieldInfo.Name);
                    }
                }
            }
            return null;
        }
        public static object ParseStringValue(Type enumType, string stringValue, bool ignoreCase, object defaultNullValue)
        {
            object result = ParseStringValue(enumType, stringValue, ignoreCase);
            if (result == null)
            {
                return defaultNullValue;
            }
            return result;
        }
        public static bool TryParseXmlEnumValue<T>(string xmlEnumValue, out T parsedEnum)
        {
            return EnumHelper<T>.TryParseXmlEnumValue(xmlEnumValue, out parsedEnum);
        }
        public static T ToEnum<T>(this string text)
            where T : struct
        {
            return EnumHelper<T>.Parse(text);
        }
        public static string ToString(object enumValue)
        {
            var helperType = typeof(EnumHelper<>).MakeGenericType(enumValue.GetType());
            return (string)helperType.InvokeMember("ToString", BindingFlags.InvokeMethod | BindingFlags.Static | BindingFlags.Public, null, null, new[] { enumValue });
        }
        public static ArgumentOutOfRangeException OutOfRange<T>(this T value, string paramName)
            where T : struct
        {
            return new ArgumentOutOfRangeException(paramName, value, "unknown or out of range value " + value + " for " + typeof(T));
        }
    }
    public static class EnumHelper<T>
    {
        public static readonly Dictionary<T, FieldInfo> MemberCache;
        private static readonly Dictionary<T, string> ToStringCache;
        private static readonly Dictionary<string, T> FromStringCache;
        private static readonly List<KeyValuePair<int, string>> FlagsCacheInt32;
        private static readonly List<KeyValuePair<byte, string>> FlagsCacheByte;
        private static readonly bool IsInt32Type;
        private static readonly bool IsByteType;
        #region .ctor
        static EnumHelper()
        {
            if (!typeof(T).IsEnum)
                throw new NotSupportedException("EnumHelper is for Enums only, obviously");
            if (Enum.GetUnderlyingType(typeof(T)) == typeof(Int32))
                IsInt32Type = true;
            if (Enum.GetUnderlyingType(typeof(T)) == typeof(Byte))
                IsByteType = true;
            if (!(IsInt32Type || IsByteType))
                throw new NotSupportedException("EnumHelper just support Int32 or Byte underlying type.");
            MemberCache = Enum
                .GetValues(typeof(T))
                .Cast<T>()
                .ToDictionary(
                    value => value,
                    value => typeof(T).GetField(value.ToString())
                );
            if (IsInt32Type)
            {
                FlagsCacheInt32 = MemberCache
                .Select(pair => new KeyValuePair<int, string>((int)(object)pair.Key, pair.Value.Name))
                .OrderByDescending(pair => pair.Key)
                .ToList();
            }
            else
            {
                FlagsCacheByte = MemberCache
                .Select(pair => new KeyValuePair<byte, string>((byte)(object)pair.Key, pair.Value.Name))
                .OrderByDescending(pair => pair.Key)
                .ToList();
            }
            ToStringCache = MemberCache
                .ToDictionary(pair => pair.Key, pair => typeof(T).Name + '.' + pair.Value.Name);
            FromStringCache = MemberCache
                .ToDictionary(pair => pair.Value.Name, pair => pair.Key);
        }
        #endregion
        #region EnumStringValues
        private static IDictionary<T, String> _stringValues;
        private readonly static object StringValuesCacheSyncRoot = new object();
        public static IDictionary<T, String> StringValues
        {
            get
            {
                if (_stringValues == null)
                {
                    lock (StringValuesCacheSyncRoot)
                    {
                        if (_stringValues == null)
                        {
                            _stringValues = Enum.GetValues(typeof (T))
                                                .Cast<T>()
                                                .ToDictionary(k => k, k => EnumHelper.GetStringValueInternal(k));
                        }
                    }
                }
                return _stringValues;
            }
        }
        #endregion EnumStringValues
        #region XmlEnumAttribute
        private static Dictionary<string, List<T>> _fromXmlEnumNameCache;
        private readonly static object FromXmlEnumNameCacheSyncRoot = new object();
        private static Dictionary<string, List<T>> FromXmlEnumNameCache
        {
            get
            {
                if (_fromXmlEnumNameCache == null)
                {
                    lock (FromXmlEnumNameCacheSyncRoot)
                    {
                        if (_fromXmlEnumNameCache == null)
                        {
                            _fromXmlEnumNameCache = CreateFromXmlEnumNameCache();
                        }
                    }
                }
                return _fromXmlEnumNameCache;
            }
        }
        private static Dictionary<string, List<T>> CreateFromXmlEnumNameCache()
        {
            return MemberCache
                .Select(pair =>
                {
                    XmlEnumAttribute xmlEnumAttribute = pair.Value.GetCustomAttribute<XmlEnumAttribute>();
                    return new
                    {
                        EnumValue = pair.Key,
                        XmlEnumName = xmlEnumAttribute == null || xmlEnumAttribute.Name == null
                            ? pair.Key.ToString() : xmlEnumAttribute.Name,
                    };
                })
                .GroupBy(pair => pair.XmlEnumName)
                .ToDictionary(pair => pair.Key, pair => pair.Select(p => p.EnumValue).ToList());
        }
        public static bool TryParseXmlEnumValue(string xmlEnumValue, out T parsedEnum)
        {
            List<T> possibleValues;
            parsedEnum = default(T);
            if (FromXmlEnumNameCache.TryGetValue(xmlEnumValue, out possibleValues)
                && possibleValues != null
                && possibleValues.Count == 1)
            {
                parsedEnum = possibleValues.First();
                return true;
            }
            return false;
        }
        #endregion
        public static IEnumerable<T> Values
        {
            get { return MemberCache.Keys; }
        }
        public static string GetName(T value)
        {
            return MemberCache[value].Name;
        }
        public static IList GetStringValues()
        {
            return StringValues.ToList();
        }
        public static string ToString(T value)
        {
            return ToStringCache.GetOrAdd(value, ResolveToString);
        }
        private static string ResolveToString(T value)
        {
            var sb = new StringBuilder();
            var prefix = typeof(T).Name + '.';
            var i = (int)(object)value;
            if (IsInt32Type)
            {
                foreach (var name in FlagsCacheInt32)
                {
                    if ((i & name.Key) != name.Key)
                        continue;
                    if (sb.Length != 0)
                        sb.Append('|');
                    sb.Append(prefix);
                    sb.Append(name.Value);
                    i -= name.Key;
                    if (i == 0)
                        break;
                }
            }
            else
            {
                foreach (var name in FlagsCacheByte)
                {
                    if ((i & name.Key) != name.Key)
                        continue;
                    if (sb.Length != 0)
                        sb.Append('|');
                    sb.Append(prefix);
                    sb.Append(name.Value);
                    i -= name.Key;
                    if (i == 0)
                        break;
                }
            }
            return sb.ToString();
        }
        public static T ParseOrDefault(string str, T valueIfNotValid)
        {
            T value;
            return (!string.IsNullOrEmpty(str) && FromStringCache.TryGetValue(str, out value))
                       ? value
                       : valueIfNotValid;
        }
        public static T ParseOrDefault(string str)
        {
            return ParseOrDefault(str, default(T));
        }
        public static T Parse(string value)
        {
            return EnumHelper.SafeParse<T>(value);
        }
        /// <summary>
        /// Tip: Use it as ParseStringValue&lt;MyEnum?&gt;(string).
        /// Otherwise, if given string cannot be parsed, it will return your enum default value.
        /// </summary>
        public static T ParseStringValue(string value)
        {
            var typ = typeof(T);
            if (typ.IsNullable())
                typ = typ.GetGenericArguments()[0];
            return (T)(EnumHelper.ParseStringValue(typ, value, false) ?? default(T));
        }
        /// <summary>
        /// for Enum { First, [Att]Second, Third } return { Second }
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <typeparam name="TAttribute"></typeparam>
        /// <returns></returns>
        public static IList<T> GetMembersWithAttribute<TAttribute>()
            where TAttribute : Attribute
        {
            return MemberCache
                    .Where(k => k.Value
                                    .GetCustomAttributes(typeof(TAttribute), false)
                                    .FirstOrDefault() as TAttribute != null)
                    .Select(v => v.Key)
                    .ToList();
        }
         /// <summary>
        /// Return the implementation defined by the <see cref="ImplementedByAttribute"/> attribute.
        /// </summary>
        /// <param name="enumeration">The enum</param>
        /// <returns>The description defined for the enum value, the enum value name if no DescriptionAttribute is found for the given enum value</returns>
        public static IEnumerable<TImpl> GetImplementation<TImpl>(Enum enumeration)
         {
             var list = new List<TImpl>();
             var enumType = enumeration.GetType();
             // ReSharper disable LoopCanBeConvertedToQuery
             foreach (var enumValue in Enum.GetValues(enumType))
                 // ReSharper restore LoopCanBeConvertedToQuery
             {
                 var fi = enumType.GetField(enumValue.ToString());
                 if (fi == null) continue;
                 var attrs =
                     fi.GetCustomAttributes(typeof (ImplementedByAttribute), false) as ImplementedByAttribute[];
                 if (attrs == null || attrs.Length <= 0) continue;
                 var implementBy = attrs[0];
                 list.Add(InstanceHelper.NewInstance(implementBy.ResolvedType, new object[] { }) is TImpl ? (TImpl)InstanceHelper.NewInstance(implementBy.ResolvedType, new object[] { }) : default(TImpl));
             }
             return list;
         }
    }
    public static class FlagsHelper
    {
        public static IEnumerable<T> GetFlags<T>(this T input)
            where T : struct
        {
            Enum flags = input as Enum;
            if (flags != null)
            {
                foreach (T value in Enum.GetValues(typeof(T)).Cast<T>())
                {
                    if (flags.HasFlag(value))
                        yield return value;
                }
            }
        }
        //checks if the value contains the provided type
        //beware it is not the fastest way of testing it
        public static bool HasFlag<T>(this Enum type, T value)
        {
            try
            {
                return (((int)(object)type & (int)(object)value) == (int)(object)value);
            }
            catch
            {
                return false;
            }
        }
        //checks if the value is only the provided type
        public static bool IsFlag<T>(this Enum type, T value)
        {
            try
            {
                return (int)(object)type == (int)(object)value;
            }
            catch
            {
                return false;
            }
        }
        //appends a value
        public static T AddFlag<T>(this Enum type, T value)
        {
            try
            {
                return (T)(object)(((int)(object)type | (int)(object)value));
            }
            catch (Exception ex)
            {
                throw new ArgumentException(
                    string.Format(
                        "Could not append value from enumerated type '{0}'.",
                        typeof(T).Name
                        ), ex);
            }
        }
        //completely removes the value
        public static T RemoveFlag<T>(this Enum type, T value)
        {
            try
            {
                return (T)(object)(((int)(object)type & ~(int)(object)value));
            }
            catch (Exception ex)
            {
                throw new ArgumentException(
                    string.Format(
                        "Could not remove value from enumerated type '{0}'.",
                        typeof(T).Name
                        ), ex);
            }
        }
    }
}
=====
using System.Collections.Generic;
using System.Collections.Specialized;
// ReSharper disable CheckNamespace
namespace System.Collections.ObjectModel
// ReSharper restore CheckNamespace
{
    /// <summary>
    /// Observable dictionary.
    /// </summary>
    /// <typeparam name="TKey">Key type.</typeparam>
    /// <typeparam name="TValue">Value type.</typeparam>
    [Serializable]
    public class XObservableDictionary<TKey, TValue>
        : IDictionary<TKey, TValue>,
          INotifyCollectionChanged,
          IEquatable<Object>
    {
        #region Properties
        /// <summary>
        /// Dictionary.
        /// </summary>
        protected IDictionary<TKey, TValue> InternalDictionary { get; private set; }
        #endregion Properties
        #region Constructors
        /// <summary>
        /// Initializes a new instance of the <see cref="XObservableDictionary{TKey,TValue}"/> class.
        /// </summary>
        public XObservableDictionary()
        {
            InternalDictionary = new Dictionary<TKey, TValue>();
        }
        /// <summary>
        /// Initializes a new instance of the <see cref="XObservableDictionary{TKey,TValue}"/> class
        /// with the specified dictionary.
        /// </summary>
        /// <param name="dictionary">Dictionary.</param>
        public XObservableDictionary(IDictionary<TKey, TValue> dictionary)
        {
            InternalDictionary = new Dictionary<TKey, TValue>(dictionary);
        }
        /// <summary>
        /// Initializes a new instance of the <see cref="XObservableDictionary{TKey,TValue}"/> class
        /// with the specified key comparer.
        /// </summary>
        /// <param name="comparer">Key comparer.</param>
        public XObservableDictionary(IEqualityComparer<TKey> comparer)
        {
            InternalDictionary = new Dictionary<TKey, TValue>(comparer);
        }
        /// <summary>
        /// Initializes a new instance of the <see cref="XObservableDictionary{TKey,TValue}"/> class
        /// with the specified capacity.
        /// </summary>
        /// <param name="capacity">Capacity.</param>
        public XObservableDictionary(Int32 capacity)
        {
            InternalDictionary = new Dictionary<TKey, TValue>(capacity);
        }
        /// <summary>
        /// Initializes a new instance of the <see cref="XObservableDictionary{TKey,TValue}"/> class
        /// with the specified dictionary and key comparer.
        /// </summary>
        /// <param name="dictionary">Dictionary.</param>
        /// <param name="comparer">Key comparer.</param>
        public XObservableDictionary(IDictionary<TKey, TValue> dictionary, IEqualityComparer<TKey> comparer)
        {
            InternalDictionary = new Dictionary<TKey, TValue>(dictionary, comparer);
        }
        /// <summary>
        /// Initialise une nouvelle instance de la classe qui possde la capacit initale spcifie et qui utilise le comparateur d'galit spcifi pour le type de cl.
        /// </summary>
        /// <param name="capacity">Nombre initial d'lments que le dictionnaire peut contenir.</param>
        /// <param name="comparer">Comparateur de cls.</param>
        public XObservableDictionary(Int32 capacity, IEqualityComparer<TKey> comparer)
        {
            InternalDictionary = new Dictionary<TKey, TValue>(capacity, comparer);
        }
        #endregion
        #region Implementation of IEnumerable
        /// <summary>
        /// Returns an enumerator that iterates through the collection.
        /// </summary>
        /// <returns>
        /// A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate through the collection.
        /// </returns>
        /// <filterpriority>1</filterpriority>
        public IEnumerator<KeyValuePair<TKey, TValue>> GetEnumerator()
        {
            return InternalDictionary.GetEnumerator();
        }
        /// <summary>
        /// Returns an enumerator that iterates through a collection.
        /// </summary>
        /// <returns>
        /// An <see cref="T:System.Collections.IEnumerator"/> object that can be used to iterate through the collection.
        /// </returns>
        /// <filterpriority>2</filterpriority>
        IEnumerator IEnumerable.GetEnumerator()
        {
            return InternalDictionary.GetEnumerator();
        }
        #endregion
        #region Implementation of ICollection<KeyValuePair<TKey,TValue>>
        /// <summary>
        /// Adds an item to the <see cref="T:System.Collections.Generic.ICollection`1"/>.
        /// </summary>
        /// <param name="item">The object to add to the <see cref="T:System.Collections.Generic.ICollection`1"/>.
        ///                 </param><exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.ICollection`1"/> is read-only.
        ///                 </exception>
        public void Add(KeyValuePair<TKey, TValue> item)
        {
            Insert(item.Key, item.Value, false);
        }
        /// <summary>
        /// Removes all items from the <see cref="T:System.Collections.Generic.ICollection`1"/>.
        /// </summary>
        /// <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.ICollection`1"/> is read-only.
        ///                 </exception>
        public void Clear()
        {
            if (InternalDictionary.Count <= 0) return;
            InternalDictionary.Clear();
            OnCollectionItemsCleared();
        }
        /// <summary>
        /// Determines whether the <see cref="T:System.Collections.Generic.ICollection`1"/> contains a specific value.
        /// </summary>
        /// <returns>
        /// true if <paramref name="item"/> is found in the <see cref="T:System.Collections.Generic.ICollection`1"/>; otherwise, false.
        /// </returns>
        /// <param name="item">The object to locate in the <see cref="T:System.Collections.Generic.ICollection`1"/>.
        ///                 </param>
        public Boolean Contains(KeyValuePair<TKey, TValue> item)
        {
            return InternalDictionary.Contains(item);
        }
        /// <summary>
        /// Copies the elements of the <see cref="T:System.Collections.Generic.ICollection`1"/> to an <see cref="T:System.Array"/>, starting at a particular <see cref="T:System.Array"/> index.
        /// </summary>
        /// <param name="array">The one-dimensional <see cref="T:System.Array"/> that is the destination of the elements copied from <see cref="T:System.Collections.Generic.ICollection`1"/>. The <see cref="T:System.Array"/> must have zero-based indexing.
        ///                 </param><param name="arrayIndex">The zero-based index in <paramref name="array"/> at which copying begins.
        ///                 </param><exception cref="T:System.ArgumentNullException"><paramref name="array"/> is null.
        ///                 </exception><exception cref="T:System.ArgumentOutOfRangeException"><paramref name="arrayIndex"/> is less than 0.
        ///                 </exception><exception cref="T:System.ArgumentException"><paramref name="array"/> is multidimensional.
        ///                     -or-
        ///                 <paramref name="arrayIndex"/> is equal to or greater than the length of <paramref name="array"/>.
        ///                     -or-
        ///                     The number of elements in the source <see cref="T:System.Collections.Generic.ICollection`1"/> is greater than the available space from <paramref name="arrayIndex"/> to the end of the destination <paramref name="array"/>.
        ///                     -or-
        ///                     Type T cannot be cast automatically to the type of the destination <paramref name="array"/>.
        ///                 </exception>
        public void CopyTo(KeyValuePair<TKey, TValue>[] array, Int32 arrayIndex)
        {
            InternalDictionary.CopyTo(array, arrayIndex);
        }
        /// <summary>
        /// Removes the first occurrence of a specific object from the <see cref="T:System.Collections.Generic.ICollection`1"/>.
        /// </summary>
        /// <returns>
        /// true if <paramref name="item"/> was successfully removed from the <see cref="T:System.Collections.Generic.ICollection`1"/>; otherwise, false. This method also returns false if <paramref name="item"/> is not found in the original <see cref="T:System.Collections.Generic.ICollection`1"/>.
        /// </returns>
        /// <param name="item">The object to remove from the <see cref="T:System.Collections.Generic.ICollection`1"/>.
        ///                 </param><exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.ICollection`1"/> is read-only.
        ///                 </exception>
        public Boolean Remove(KeyValuePair<TKey, TValue> item)
        {
            TValue value;
            if (!InternalDictionary.TryGetValue(item.Key, out value)) return false;
            InternalDictionary.Remove(item.Key);
            OnCollectionItemAddedOrRemoved(NotifyCollectionChangedAction.Remove, new KeyValuePair<TKey, TValue>(item.Key, value));
            return true;
        }
        /// <summary>
        /// Gets the number of elements contained in the <see cref="T:System.Collections.Generic.ICollection`1"/>.
        /// </summary>
        /// <returns>
        /// The number of elements contained in the <see cref="T:System.Collections.Generic.ICollection`1"/>.
        /// </returns>
        public Int32 Count
        {
            get
            {
                return InternalDictionary.Count;
            }
        }
        /// <summary>
        /// Gets a value indicating whether the <see cref="T:System.Collections.Generic.ICollection`1"/> is read-only.
        /// </summary>
        /// <returns>
        /// true if the <see cref="T:System.Collections.Generic.ICollection`1"/> is read-only; otherwise, false.
        /// </returns>
        public Boolean IsReadOnly
        {
            get
            {
                return InternalDictionary.IsReadOnly;
            }
        }
        #endregion
        #region Implementation of IDictionary<TKey,TValue>
        /// <summary>
        /// Determines whether the <see cref="T:System.Collections.Generic.IDictionary`2"/> contains an element with the specified key.
        /// </summary>
        /// <returns>
        /// true if the <see cref="T:System.Collections.Generic.IDictionary`2"/> contains an element with the key; otherwise, false.
        /// </returns>
        /// <param name="key">The key to locate in the <see cref="T:System.Collections.Generic.IDictionary`2"/>.
        ///                 </param><exception cref="T:System.ArgumentNullException"><paramref name="key"/> is null.
        ///                 </exception>
        public Boolean ContainsKey(TKey key)
        {
            return InternalDictionary.ContainsKey(key);
        }
        /// <summary>
        /// Adds an element with the provided key and value to the <see cref="T:System.Collections.Generic.IDictionary`2"/>.
        /// </summary>
        /// <param name="key">The object to use as the key of the element to add.
        ///                 </param><param name="value">The object to use as the value of the element to add.
        ///                 </param><exception cref="T:System.ArgumentNullException"><paramref name="key"/> is null.
        ///                 </exception><exception cref="T:System.ArgumentException">An element with the same key already exists in the <see cref="T:System.Collections.Generic.IDictionary`2"/>.
        ///                 </exception><exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.IDictionary`2"/> is read-only.
        ///                 </exception>
        public void Add(TKey key, TValue value)
        {
            Insert(key, value, false);
        }
        /// <summary>
        /// Removes the element with the specified key from the <see cref="T:System.Collections.Generic.IDictionary`2"/>.
        /// </summary>
        /// <returns>
        /// true if the element is successfully removed; otherwise, false.  This method also returns false if <paramref name="key"/> was not found in the original <see cref="T:System.Collections.Generic.IDictionary`2"/>.
        /// </returns>
        /// <param name="key">The key of the element to remove.
        ///                 </param><exception cref="T:System.ArgumentNullException"><paramref name="key"/> is null.
        ///                 </exception><exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.IDictionary`2"/> is read-only.
        ///                 </exception>
        public Boolean Remove(TKey key)
        {
            TValue value;
            if (!InternalDictionary.TryGetValue(key, out value)) return false;
            InternalDictionary.Remove(key);
            OnCollectionItemAddedOrRemoved(NotifyCollectionChangedAction.Remove, new KeyValuePair<TKey, TValue>(key, value));
            return true;
        }
        /// <summary>
        /// Gets the value associated with the specified key.
        /// </summary>
        /// <returns>
        /// true if the object that implements <see cref="T:System.Collections.Generic.IDictionary`2"/> contains an element with the specified key; otherwise, false.
        /// </returns>
        /// <param name="key">The key whose value to get.
        ///                 </param><param name="value">When this method returns, the value associated with the specified key, if the key is found; otherwise, the default value for the type of the <paramref name="value"/> parameter. This parameter is passed uninitialized.
        ///                 </param><exception cref="T:System.ArgumentNullException"><paramref name="key"/> is null.
        ///                 </exception>
        public Boolean TryGetValue(TKey key, out TValue value)
        {
            return InternalDictionary.TryGetValue(key, out value);
        }
        /// <summary>
        /// Gets or sets the element with the specified key.
        /// </summary>
        /// <returns>
        /// The element with the specified key.
        /// </returns>
        /// <param name="key">The key of the element to get or set.
        ///                 </param><exception cref="T:System.ArgumentNullException"><paramref name="key"/> is null.
        ///                 </exception><exception cref="T:System.Collections.Generic.KeyNotFoundException">The property is retrieved and <paramref name="key"/> is not found.
        ///                 </exception><exception cref="T:System.NotSupportedException">The property is set and the <see cref="T:System.Collections.Generic.IDictionary`2"/> is read-only.
        ///                 </exception>
        public TValue this[TKey key]
        {
            get
            {
                return InternalDictionary[key];
            }
            set
            {
                Insert(key, value, true);
            }
        }
        /// <summary>
        /// Gets an <see cref="T:System.Collections.Generic.ICollection`1"/> containing the keys of the <see cref="T:System.Collections.Generic.IDictionary`2"/>.
        /// </summary>
        /// <returns>
        /// An <see cref="T:System.Collections.Generic.ICollection`1"/> containing the keys of the object that implements <see cref="T:System.Collections.Generic.IDictionary`2"/>.
        /// </returns>
        public ICollection<TKey> Keys
        {
            get
            {
                return InternalDictionary.Keys;
            }
        }
        /// <summary>
        /// Gets an <see cref="T:System.Collections.Generic.ICollection`1"/> containing the values in the <see cref="T:System.Collections.Generic.IDictionary`2"/>.
        /// </summary>
        /// <returns>
        /// An <see cref="T:System.Collections.Generic.ICollection`1"/> containing the values in the object that implements <see cref="T:System.Collections.Generic.IDictionary`2"/>.
        /// </returns>
        public ICollection<TValue> Values
        {
            get
            {
                return InternalDictionary.Values;
            }
        }
        #endregion
        #region Implementation of INotifyCollectionChanged
        /// <summary>
        /// Triggered when the dictionary content changes.
        /// </summary>
        public event NotifyCollectionChangedEventHandler CollectionChanged;
        /// <summary>
        /// Triggers <see cref="CollectionChanged"/> with the specified action and item.
        /// </summary>
        /// <param name="action">Action.</param>
        /// <param name="changedItem">Changed item.</param>
        protected virtual void OnCollectionItemAddedOrRemoved(NotifyCollectionChangedAction action, KeyValuePair<TKey, TValue> changedItem)
        {
            if (CollectionChanged != null)
            {
                CollectionChanged(this, new NotifyCollectionChangedEventArgs(action, changedItem));
            }
        }
        /// <summary>
        /// Triggers <see cref="CollectionChanged"/> with <see cref="NotifyCollectionChangedAction.Replace"/>
        /// and the specified new items and old items.
        /// </summary>
        /// <param name="newItem">New items.</param>
        /// <param name="oldItem">Old items.</param>
        protected virtual void OnCollectionChanged(KeyValuePair<TKey, TValue> newItem, KeyValuePair<TKey, TValue> oldItem)
        {
            if (CollectionChanged != null)
            {
                CollectionChanged(this, new NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction.Replace, newItem, oldItem));
            }
        }
        /// <summary>
        /// Triggers <see cref="CollectionChanged"/> with <see cref="NotifyCollectionChangedAction.Reset"/>.
        /// </summary>
        protected virtual void OnCollectionItemsCleared()
        {
            if (CollectionChanged != null)
            {
                CollectionChanged(this, new NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction.Reset));
            }
        }
        #endregion
        #region Methods
        /// <summary>
        /// Inserts or updates an element with the specified key and value ; with or without overwriting its data.
        /// </summary>
        /// <param name="key">Key.</param>
        /// <param name="value">Value.</param>
        /// <param name="overwrite"><see langword="true"/> if the item can be overwritten; otherwise, <see langword="false"/>.</param>
        private void Insert(TKey key, TValue value, Boolean overwrite)
        {
            // NOTE: Although key is not always a class type (and therefore null-able), it can be.
            // ReSharper disable CompareNonConstrainedGenericWithNull
            if (key == null) throw new ArgumentNullException("key");
            // ReSharper restore CompareNonConstrainedGenericWithNull
            TValue item;
            if (InternalDictionary.TryGetValue(key, out item))
            {
                if (!overwrite) throw new ArgumentException("An item with the same key has already been added.");
                if (!Equals(item, value))
                {
                    InternalDictionary[key] = value;
                    OnCollectionChanged(new KeyValuePair<TKey, TValue>(key, value), new KeyValuePair<TKey, TValue>(key, item));
                }
            }
            else
            {
                InternalDictionary[key] = value;
                OnCollectionItemAddedOrRemoved(NotifyCollectionChangedAction.Add, new KeyValuePair<TKey, TValue>(key, value));
            }
        }
        #endregion Methods
    }
}

